---
layout:     post
title:      "SketchUp插件Ruby开发指南"
subtitle:   ""
author:     "wml"
header-img: "img/bg-1.png"
header-mask:  0.5
catalog: true
tags:
    - rebase
---

## 前言
虽然我是一名程序员，但工程学始终是我的最爱。计算机辅助工程（CAE）一直对我特别着迷，尤其是有限元分析（FEA）和形状优化领域。这就是比特和字节的世界与质量、热和电的世界的交汇之处。

但在实践中使用FEA工具之前，必须有一种方法来形成三维图形的计算机表示。我研究了许多当今流行的CAD工具，虽然它们都具有极高的learning curves(学习曲线)、专有的设计格式，但最糟糕的是价格高昂。另一方面，SketchUp是基本版免费提供的，而且学习起来非常简单。当我完全熟练掌握应用程序时，我仍然记得在一个美好的下午开玩笑。因为我不是艺术家，所以我很高兴发现有一种脚本语言。

本书的目标是解释如何使用这种脚本语言来充分利用SketchUp的潜力。许多人一开始不愿意尝试脚本，这是有道理的 - 用户界面使用起来非常直观。但是，一旦您通过脚本打开一扇扇的魔法门，您就会像我一样专注于自动SketchUp。

## 致谢
这本书要感谢很多人，我尤其要感谢三位：John Boundy，Kelly Johnson和Octavian Chis。John Boundy阅读了大部分文本并测试了本书中的每个脚本示例。在此过程中，他提出了许多非常有用的意见和建议。这些不仅改善了脚本的操作，而且改善了设计的外观。他以极快的速度工作，一天发送超过20封电子邮件，我无法用语言来表达我的感激之情。

博雷戈出版公司的Kelly Johnson在制作期间处理了大量的文案编辑和校对。她在出版领域的经验极大地促进了本书的专业质量，她煞费苦心的编辑的同时大大减少了拼写错误和格式错误的数量。感谢Kelly！

最后，我要感谢Octavian Chis（  他的朋友和粉丝）。他是SketchUp脚本的资深人士，在本书的早期开发过程中提供了帮助和支持。他解决了我的一些问题，并为回答困难问题提供了资源。


# 第1章 SketchUp脚本简介
本章主题
* [SketchUp 脚本简要:阐述与学习动机](SketchUp脚本简要:阐述与学习动机)
* [SketchUp 和 Ruby 程序设计语言](SketchUp和Ruby程序设计语言)
* [本书的组织](本书的组织)

有许多三维建模工具可供使用，争论仍然激烈，提供了最好的功能。但是，当涉及到易用性和纯粹的乐趣时，SketchUp® 将获得成功。它的用户界面非常直观，大多数用户可以在几分钟内学习基础知识。它的学习曲线非常让人轻松，新手可以在几个小时内成为专家。

大多数建模工具都针对特定受众。AutoCAD® 吸引了工程类型，而动画师和图形艺术家更喜欢Maya® ，Blender® 或3dsMax® 。但SketchUp有更广泛的观点。这体现在它的口号和存在理由： “3D for Everyone”。

从各方面来看，SketchUp 不会辜负它的目标。不仅建筑 师和工程师容易接受，而且在其他领域如木工、图形艺术家、 动画师、数学家以及其他创造性的类型等等。如果SketchUp无法满足您的特殊需求，您可以通过插件扩充其功能 - 本书深入探讨了这一主题。

## 学习 SketchUp 脚本的十个理由
SketchUp的用户界面是它的主要优势之一，因此有一本专门用于SketchUp基于文本的命令的书可能看起来很奇怪，甚至落伍。但也有为什么要学习 SketchUp 脚本的原因，下面列 出学习的10个主要优点，没有特定的顺序:

1. 丰富的设计管理——SketchUp 的组件和群组可以创建设 计元素的层次结构。一个大型的设计，如商场，可能包括上千 个组件及子组件，甚至子子子组件。这时，在设计时使用脚本 会比设计窗口更容易管理这些层级，也使其他开发人员更容易 查看和分析。

2. 插件——SketchUp 插件可以扩展功能，以完善应用程序， 如新的菜单项、在工具栏上的新工具图标、新的对话框和许多 其它的可能性。正如我们看到的，一个插件就是放置于某个目 录中的 SketchUp 脚本文件，第10章中阐述的正是这些插件是 如何编写和部署。

3. 不需鼠标点击访问设计对象——在 SketchUp 中，当您设 计的是简单的形状时，只要您手巧的话，您有能力找到并选择 对象，这不是一个问题。但它变成笨拙且复杂的模型，类似于 多面体。在脚本中您可以很容易地遍历每一个设计元素和您只 感兴趣的操作。

4. 在任何地方，绘制任何东西——通常情况下，您只能在您 的视图下绘制对象，您必须依靠辅助点、带颜色的坐标轴和数 值输入框。对于一个新的设计，您只能在 XY、XZ、YZ 上创 建平面形状。而在 SketchUp 脚本中，这些都不会限制，只要 您喜欢，您可以画任何您喜欢的。

5. 动画——SketchUp 提供多种方式来创建和移动，您可以 更改设计的角度，或者创建具有多个页面的幻灯片。但在 SketchUp 脚本中，您可以使用简单的旋转物体动画的的层次 结构，比如骨骼动画。如果还不明白我的意思，直接跳到12章 的跳舞的机器人。

6. 免费、友好的支持——谷歌专门为 SketchUp 的支持和公告设立一个[用户组](http://groups.google.com/group/google-sketchup-developers)。不管有任何问题，您都可以收到答复。此外，在[论坛](http://www.sketchucation.com)也提供丰富的支持和信息。

7. 自动化——SketchUp 的命令存储在脚本的主要优点之一， 就是您只需要键入命令一次。之后，可以重复执行该脚本。要 进行更改，只需在文本编辑器中编辑脚本，您还可以在脚本之 间剪切和粘贴命令。

8. Web 访问——第13章中讨论 SketchUp 使用 Webdialogs 可以访问英特网上任何的网站，这些对话框也可以作为 JavaScript 代码和 SketchUp 之间的桥梁。

9. 丰富的插件脚本——SketchUp 开发者社区是活跃和繁荣 的，如果您的项目有新的功能要求，可能有人已经编写了这样 一个功能的脚本，您可以下载使用。

10. 乐趣——在所有的软件开发过程中，没有一个能够像 SketchUp 这样能够直观地看到一个崭新三维模型，以及更复 杂的设计，这将会给您带来更大的享受。

## 1.2 获取并安装SketchUp
如果您还没有安装SketchUp，请让我解释一下这个过程。首先，访问该[网站.](http://sketchup.google.com/download) 在右侧，您将看到下载常规SketchUp（免费）和SketchUp Pro的链接（撰写本文时为495美元）。SketchUp Pro提供专业的布局和样式，高级文件操作和全面的技术支持。但是，免费版仍提供大量功能。SketchUp仅在MicrosoftWindows® 和Mac® 操作系统上本机运行，但Linux用户可以通过WINE模拟器访问SketchUp。单击其中一个链接，完成用户协议，您可以选择将文件（Windows上的* .exe，Mac上的* .dmg）下载到您的系统。

注意：本节中的说明与本书中的说明一样，都是针对SketchUp 7.1和SketchUp 7.1应用程序编程接口（API）。
### 在Windows操作系统上安装
在 Microsoft Windows 上，安装 SketchUp 很简单。双击可执行文件，并单击“下一步” ，出现安装程序对话框。接 受许可协议，单击“下一步”两次，并点击安装。安装完毕后， 单击完成，SketchUp 将准备运行。图1.1 显示了如果你选择 了工程模板，应用程序在 Microsoft Windows下的状态。
![1](/img/Ruby/Chapter_01/1.png)
<center>图1.1：Windows操作系统中的SketchUp用户界面</center>
### 在Mac OS X系统上安装
在 Mac OS X，打开 . dmg 文件安装程序。出现安装程序对话框，单击“继续”，阅读许可协议，并单击“继续”， 并同意。下一步，选择你想安装 SketchUp 卷和点击继续，选 择执行标准安装，安装后，单击“关闭”。图1.2 显示了安装 后的 SketchUp 的用户界面。
![2](/img/Ruby/Chapter_01/2.png)
<center>图1.2：Mac OS X中的SketchUp用户界面</center>
## 1.3 一个简单的例子
我知道我们仍然在第一章，这本书即将要开始谈论一些技 术细节。需要更进一步，希望你能大概知道 SketchUp 命令看 起来应该如何。如果你喜欢尝试，想马上执行的命令，我建议 你打开 SketchUp 中，打开“窗口”菜单，并选择 Ruby 控制 台。我们的 SketchUp 命令都将从这里输入。

比方说，你要从原点画一条线，[0，0，0] 到 [5，5，5]。 通常，这需要鼠标点击三次:在 SketchUp 工具栏单击直线工 具，然后单击坐标原点，当鼠标指针到达 [5，5，5] 时点击终 点。但是你也可以使用下面的命令行画出:
```ruby
Sketchup.active_model.entities.add_line [0,0,0], [5,5,5]
```
如果要执行该命令，需要在 Ruby 控制台窗口输入上述代 码，然后按回车。图1.3a 显示 Windows 操作系统下的控制台 窗口，图1.3b 是在 Mac OS X 下的控制台窗口。
![3](/img/Ruby/Chapter_01/3.png)
<center>图1.3a：Windows中的SketchUp Ruby控制台窗口</center>
![4](/img/Ruby/Chapter_01/4.png)
<center>图1.3b：Mac OS X中的SketchUp Ruby控制台窗口</center>
当执行命令后，SketchUp 绘制 [0，0，0] 到 [5，5，5] 的直线，与直接使用直线工具比起来，它比鼠标移动和点击需 要更多的时间键入命令，但如果存储在一个脚本文件中，你就 可以和其他命令一块自动执行它。当你只绘制直线时，这并没 有很大的好处。但是当按你的需求，要绘制抛物线、螺旋线和 样条曲线时，命令脚本用起来就异常方便。

自动化可能是复杂的，所以许多用户将总是宁可点来点去， 这也没有什么错。如果 SketchUp 命令接口让你感到无助，这 也没关系。如果你有这样的感觉，我强烈建议你阅读《The Google SketchUp Cookbook》或《Google SketchUp for Dummies》这些精品教学图书。

但是，如果前面的命令示例能激发你的好奇心，并想了解 更多，那么这就是为你准备的书了。你不仅会看到如何创建每 一个可以想象的 SketchUp 设计元素，还能够添加自定义功能 到 SketchUp 中，包括新的工具、页面、菜单项和插件。

## 1.4 SketchUp 脚本和 Ruby
这本书涵盖了大量的技术术语，SketchUp 命令的基本语 言是 Ruby。 Ruby 是一种编程语言，其主要用途在于开发 Web 应用程序(Ruby on Rails)。

基于 Ruby 语言的 SketchUp 命令有许多优点。以下三个 是最重要的:
1. 广泛的功能——如果你只画线、面，以及类似的几何对象，那么 SketchUp 的脚本将是非常有限的。但是，随着 Ruby 的高层次的功能，控制结构、迭代循环、条件语句， 你的SketchUp脚本可以处理从低级图形优化到高层次的网络接入等等很多功能。

2. 大量现成可用函数——比如你需要在指定位置使用球面坐标， 而不是传统的直角坐标，这就需要计算正弦和余弦，如果重 新编写代码可以是说很痛苦。但在 Ruby 中，你只需调用 Math.sin 和 Math.cos。如果需要读取一个文件，或者解析一个字符串，或者 telnet 到远程系统?这些在Ruby标准库中 也是可实现的。您可以访问该[站点](http://www.ruby-doc.org) ，了解 Ruby的全部功能。

3. 面向对象——“对象”一词是在这本书中很多。一方面，它可能是指一个东西，在 SketchUp 设计中，比如创建直线、 圆或立方体。另一方面，“对象”也可以指一个特定类型的 数据结构，如果这样的说法使你迷茫，请不要担心。你现在 需要记住的是，现代的软件开发中，面向对象是一个重要的 先决条件，不仅可以方便编程维护和编写结构良好的代码， 而且使用它能够让你成为一个更明智的人。

当然，如果您已经使用Ruby编程，SketchUp的Ruby界面的最大优势在于您已经熟悉该语言。在这种情况下，您可以跳过本书中的大量介绍性材料。一旦你有机会，我建议你直接进入第3章。

而对于非专业程序员，即使在专业程序员中，Ruby的经验也很少见。所以，如果您在阅读本书之前从未编写过Ruby脚本，请不要担心。我假设你从来没有听说过Ruby。事实上，我会假设你以前从写过任何脚本代码。

所以这会是一个挑战:我希望这本书对新手尽可能友好，而不会对专家太过无聊。以下部分介绍了如何组织本书以满足两个受众的需求。

## 1.5 本书组织
Ruby 的技术讲解将至少需要三个章节。原先我计划在 2~4章来介绍这方面的内容。但编写 SketchUp 脚本有这么多的乐趣，所以我决定将这三章穿插在 SketchUp 章节之间来介 绍。因此，第2、5、8章介绍的重点是 Ruby，如果你已经是 一个 Ruby 专家，那么随时可以跳过这三章。

至于 SketchUp 的具体教学章节，我采用更通俗易懂和直 观的讲解方式，从简单、一般到复杂。所以在这本书中的章节 可以分为三个部分:
1. 第1部分由第2~6章组成，对 Ruby 和 SketchUp 进行一个基 本的介绍。一旦你读完这些章节，你就可以在 SketchUp 设 计窗口中创建任何类型的形状，你还可以对所创建的每个图 形改变其位置、缩放和外观形状。

2. 第2部分由第7~9章组成，介绍了如何通过属性、选项和观 察器创建和管理 SketchUp 设计的层级和附加属性。如果设 计比较简单，这些功能是没有必要的，但随着您的模型复杂 性的增加，将变的极其重要。

3. 第3部分由第10~13章组成，将讨论更高级的 SketchUp 操 作，这几章将讨论插件以及其他不同方式来增加功能到 SketchUp 用户界面。而最后两个议题是最有趣的:动画和 WebDialogs联系在一起。

在本书中，将提供示例SketchUp脚本以阐明概念并说明如何在代码中使用命令。要下载示例脚本，请访问[该网站](http://www.automaticsketchup.com)。 该网站还提供对勘误表的访问以及对图书内容的更新。

## 1.6 结论
乍一看，SketchUp可能看起来更像是儿童的绘图应用程序，而不是专业的建模工具。但随着您对SketchUp越来越熟悉，您可以欣赏其广泛的功能和功能。这只是冰山一角。如果您真的想充分利用SketchUp，您需要知道如何编写脚本。

本章详细讨论了SketchUp脚本的优点，但我想再次关注有趣的方面。我通常不喜欢编程，但SketchUp脚本不像常规编码。执行时，SketchUp脚本可以立即创建对象，模型， 材料，甚至动画。对于一个笨拙的非艺术家，比如我自己几乎无法画出棒图，这是纯粹的快乐。

SketchUp脚本基于Ruby编程语言，在接下来的章节中，我将尽力解释Ruby的深度，以使SketchUp的功能易于理解。如果您想了解有关Ruby的更多信息，我建议您访问该[网站](http://www.ruby-doc.org)和免费在线书籍编程Ruby：[实用程序员指南](http://www.rubycentral.com/book/)。要获得SketchUp脚本的进一步支持，[http://www.sketchucation.com](http://www.sketchucation.com) 和[http://groups.google.com/group/google-sketchup-developers](http://groups.google.com/group/google-sketchup-developers)对您来说再好不过了。

在阅读本书的过程中，我强烈建议您尝试新的命令和脚本。不要只是查看示例列表，但实际上是亲自动手并尝试新的建模思路。这不仅可以让您更好地理解材料，而且可以更好地享受SketchUp脚本。


# 第2章 Ruby课程＃1：数据结构
本章主题
* [Ruby数字、字符和数组](Ruby数字、字符和数组)
* [存储数据的变量和常量](存储数据的变量和常量)
* [面向对象的Ruby程序语言](面向对象的Ruby程序语言)

要想通过代码访问 SketchUp，那么你需要会说它的语言:Ruby。 本章的目的就是让你了解 Ruby 编程的基础——它的语言及基本数据结 构，将从数值、文字到变量、常量，还有数组的讨论开始介绍。

在每一步中，列举了大量可以让你自行输入和执行命令的例子。我 建议你不要仅限于书中的命令，还要体验其他不同的命令。这将提高你 对 Ruby 编程语言的理解，让你更熟悉整体代码环境。

在本章的最后一部分将涉及 Ruby 的面向对象编程，并讨 论对象、类和方法等相关内容。一旦这些内容明朗，你就可进 入第3章，在此基础上学习 SketchUp 建模的基础知识，这正 是真正的乐趣开始的地方，但你必须要先会走，然后才能跑。

## 2.1 Ruby控制台窗口
如果你还没有准备好，那么先启动 SketchUp，打开“窗 口”下拉菜单，选择“Ruby 控制台”。Ruby 控制台允许你 每次输入并执行一个命令。后续章节会解释如何创建存储多个 Ruby 语句的脚本，但是现在，我们只研究单个的 Ruby 命令。

Ruby 控制台很容易使用。在文本框中输入命令，然后按 回车，结果会显示在控制台对话框中的上半部分。要看到这是 如何工作的，请输入以下命令:
```ruby
2+2
```
然后按回车，在控制台中将显示命令和输出结果:4。如 图2.1所示。
![1](/img/Ruby/Chapter_02/1.png)
<center>图2.1 Ruby 控制台输入与输出</center>

2+2是一个有效的 Ruby 命令，类似于算术表达式。数值 表达式是开始学习 Ruby 的最简单方式，下节中将有更详细的 讲解。

## 2.2 数字和数值运算
当你使用 Ruby 创建 SketchUp 模型时，一个常见的任务 就是定义点、线、面。每个点由三个数字坐标组成，这对理解 Ruby 如何处理数字来说是非常重要的。本节将讨论数字格式、 运算以及运算顺序。

### 2.2.1 整数和浮点数
在这本书中，我们将处理两种类型的数字:整数和浮点数。整数，就是一个没有小数点的数字。数字前面的“+”号表示 正值，“-”号表示负值。如果没有给定符号，则该值假定为 正值。

遇到比较大的数值时，我们通常用半角逗号来分隔，但在 Ruby 中是用下划线来分隔。例如一百万，可以表示为1000000或1_000_000。为了测试这一点，在命令行中输入以 下命令:
```ruby
5_000/4
```
结果是1250，与输入5000/4相同。

浮点数是用小数点分开，包含整数部分和小数部分。在 Ruby 中，每个浮点数的小数点前后都必须至少有一个数字。 也就是说， 1⁄2你可以表达为0.5或0.500，但不能写成.5。

一个浮点数前面可以有“+”或“-”号，也可以使用e等 数学常数来定义一个指数。下面的浮点值是正确的:-25.4， 1.4959e11，123_456.789_012和3.14159。

Ruby 还提供了其他的数值类型，包括复杂的数字和有理 数(整数和分数的统称)。但鉴于这本书的目的，你只需要了 解整数和浮点数即可。

### 2.2.2 算术运算符
Ruby 识别所有在C和其他编程语言中常见的算术运算符:+、-、* 和 /，均已被列在 表2.1 中，包括模数和指数运算符。

| 操作      | 描述    |  整数范例 | 浮点范例 |
| --------- | -------- | ----- | -- |
| + | 加法 | 4 + 5=9 | 4.0 + 5.0 = 9.0 |
| - | 减法 | 12 - 4 = 8 | 12.0 - 4.0 = 8.0 |
| * | 乘法 | 7 * 3 = 21 | 7.0 * 3.0 = 21.0 |
| / | 除法 | 20 / 8 = 2 | 20.0 / 8.0 = 2.5 |
| %| 模数(求余) | 20 % 8 = 4 | 20.0 % 8.0 = 4.0 |
| ** | 幂数(乘方) | 3 ** 2 = 9 | 3.0 ** 2.0 = 9.0|

<center>图2.1 Ruby 控制台输入与输出</center>

 输入数据(被称作运算对象)的类型决定结果类型(整数或浮点数)，确定这点很重要。如果一个整数中减去另一个整数，其结果将始终是一个整数，加法、乘法和除法也同样适用。

如果一个运算对象是一个整数，另一个是浮点数，其结果将永远是一个浮点数。下面的例子就说明了这一点:
*   90-82返回8
*   90.0–82返回8.0
*   3 * 4 返回 12
*   3 * 4.0 返回 12.0
*   4/3返回1
*   4 / 3.0 返回 1.33333333333333
*   3/4返回0
*   3 / 4.0 返回0.75

在上述最后四个数值运算中使用的除法运算，结果很明显。 如果运算对象中一个是浮点数，则其结果也是浮点数。同样如 果两个数都是整数，如 A / B，返回的结果也将是整数，其余 的将被舍弃。

为了获得除法中整数的余数，你需要用 表2.1 的第五个运 算:模运算符或%。弄明白这一点的最好办法是通过示例。如 果17除以5，结果是3余2。在 Ruby 中，这意味着 17/5=3 和 17%5= 2。如果数值 a 能够整除 b，则 a%b 的结果将永远是 零。因此，你应该能够理解下列运算:
*   16/8返回2
*   16/8.0返回2.0
*   16%8返回0

表2.1 中的最后一个运算**，是执行求幂(乘方)操作， a**b 等同于 ab。第二个运算对象是指数，用来确定第一个运 算对象应该乘以自身多少次。例如，2 ** 3 返回8，因为 23 等 于8。

指数可以不必是整数，你可以设置指数为1⁄2 进行平方根运 算，指数为1⁄3进行立方根运算。同理，如果指数为负数，其结 果是执行正指数运算后的倒数。例如，2.0**-3 = 1/(2.0**3) = 1 / 8。

下面的例子展示**如何运算:
*   4 ** 2返回16
*   4 ** -2返回0.0625
*   4 ** 0.5返回2.0
*   4 ** 0返回1
*   4 ** (1/2) 返回1 (指数运算为 0)

数值运算在 SketchUp 设计中非常关键。正如你写代码， 要记住整数运算只返回整数，如果想要返回一个浮点的结果， 则需要其中一个运算对象为浮点数。

### 2.2.3 运算顺序
如果Ruby命令中包含多个数据运算符，运算不一定从左向右进行，而是遵循以下顺序:
1. 由左到右执行括号内的所有运算。

2. 由左到右执行所有的指数运算。

3. 由左到右执行所有的乘法和除法运算。

4. 由左到右执行所有的加法和减法运算。

请看下面的例子:
```ruby
1 + 3 * (6 – 4) ** 3 / (1 + 3)
```
Ruby 运算时将首先执行括号内的 (6-4=2) 和 (1+3=4)。 然后执行指数 (23=8)，等式可以简化为:
```ruby
1+ 3* 8 / 4
```
最后，Ruby 执行乘法 (3*8=24) 和除法 (24/4=6) 。最后 的答案相当于计算 1+6=7。

### 2.2.4 SketchUp 数值转换
离开前面纯粹的数字讨论，在SketchUp中，除了前面讲述的那些运算符，其余的都列在 表2.2 中。

| 操作      | 描述    |  范例 |
| --------- | -------- | ----- |
| cm    | 将厘米转换为英寸  | 2.54.cm = 1 |
| degrees     | 将角度转换为弧度 | 180.degrees = 3.141592653589 |   
| feet     | 将英尺转换为英寸 | 1.feet = 12.0 |  
| inch | 将英寸转换为长度 |  - - |  
| km | 将公里转换为英寸 | 1.km = 39370.0787401575 |  
| m | 将米转换为英寸 | 1.m = 39.3700787401575 |  
| mile | 将英里转换为英寸 | 1.mile = 63360.0 |  
| mm | 将毫米转换为英寸 | 1.mm = 0.0393700787401575 |  
| radians | 将弧度转换为角度 | 3.1415926535897.radians = 180 |  
| to_cm | 将英寸转换为厘米 | 0.393700787401575.to_cm = 1 |  
| to_feet | 将英寸转换为英尺 | 12.to_feet = 1.0 |  
| to_inch | 将长度转换为英寸 |  - - |  
| to_km | 将英寸转换为公里 | 39370.0787401575.to_km = 1 |   
| to_l | 将英寸转换为长度 |  - - |  
| to_m | 将英寸转换为米 | 39.3700787401575.to_m = 1 |  
| to_mile | 将英寸转换为英里 | 63360.to_mile = 1.0 |  
| to_mm | 将英寸转换为毫米 | 0.039370078740157.to_mm = 1 |  
| to_yard | 将英寸转换为码 | 36.to_yard = 1.0 |  
| yard | 将码转换为英寸 | 1.yard = 36.0 |  

<center>表2.2 SketchUp 转换运算</center>

在内部，SketchUp 的默认长度单位为英寸，即使你选择 一个以公制系统为基础的模板。出于这个原因，在 表2.2 中的 转换方式大部分为英寸与公制的转换，这些运算符与 表2.1 中 那些通过在数量后放置点“.”的运算符不同。第三节会介绍 如何在实践中使用这些运算符。

例如，下面的命令转换72英寸长度为米:
```ruby
72.to_m
```
结果返回1.8288，因为1.8288米与72英寸长度相同。
在写此书的时候，SketchUp 不可以绘制或存储小于0.001 英寸的长度，这意味着你不可以设置任何小于0.001英寸的尺寸。

这本书通常不指定尺寸，但有重要的一点要记住:所有 SketchUp 中处理角度的程序需要的是弧度值，而不是角度值。 但因为处理整数简单，这本书从角度开始，并将角度转换为弧 度。例如，要把30°转换为弧度，你会使用下面的命令:
```ruby
30.degrees
```
这可能会导致混乱，因为我们从度数转换，而不是转换为 度数。然而，角度度量在这本书中使用很频繁，最后，角度运 算的使用将成为本书的第二个特性。

## 2.3 字符串
数字编码很重要，但还有很多场合需要处理文本。当您从文件中读取字符，为 SketchUp 设计定义标签或为一个 SketchUp 新工具添加提示时，文本操作就很有必要。在我的 脚本中，我经常在脚本的执行过程中使用文本操作来显示消息。

在许多编程语言中，会区别对待单个字符和字符组。例如， 在 Java 中，”a” 是一个字符， “abcd” 是一个字符串。Ruby 没作此区分:“a” 和 “abcd” 都是字符串。一个字符串包含一个 或多个字符，包括字母、数字、标点符号和特殊字符。

在 Ruby 中，一个字符串可以包含在单引号和双引号中。 如果一个字符串被括在双引号中，Ruby 解释器将识别转义序 列(例如:\t 跳格，\n 换行)，并相应地显示它们。单引号括 起来的字符串，转义序列将被忽略。因此，“Line1\nLine2“ 将 被输出成两行，因为 \n 为换行符;然而 ‘Line1\nLine2’ 将忽略 换行符，而输出在一行上。

### 2.3.1 基本的字符操作
Ruby 提供了很多在代码中处理字符串的方法。两个最常见的运算符是 + 和 *，很容易理解他们的作用。+ 运算符将字 符串连接在一起，如下命令所示:
```ruby
"Hello," + " world"
→ Hello, world
```
乘法运算符 *，则是按指定的数重复一个字符串，如下命 令所示:
```ruby
"Hello!" * 3
→ Hello!Hello!Hello!
```

### 2.3.2 字符串和范围
一个很常见的任务是根据字符在字符串中的位置来访问这些字符，某个字符的位置被称为它的 index(索引)。在字符 串中，索引值从0开始，结尾的值为总字符长度减1。

在字符串中，由一些相邻字符组成的集合被称为子字符串， 您可以通过指定一个索引值的范围来表达一个字串。一个范围 代表一系列的值，可用下列两种方式之一来定义。第一种类型 的范围用“开始..结束”指定，代表从开始到结束的区间，包 括结束那个值。第二种类型的范围用“开始...结束”指定，代 表从开始到结束的区间，但不包括结束那个值。下面的例子说 明这一点:
*   0...4 代表区间 [0, 1, 2, 3]
*   0..4 代表区间 [0, 1, 2, 3, 4]
*   -5..-3 代表区间 [–5, –4, –3]
*   'a'...'e' 代表区间 ['a', 'b', 'c', 'd']
*   'a'..'e' 代表区间 ['a', 'b', 'c', 'd', 'e']

想要获取一个子字符串，只需在字符串后跟上想要得到的 索引值范围，不过索引值范围要写在方括号内。在 Ruby 控制 台中尝试这些命令:
```ruby
"HelloWorld"[0..2]
→ Hel
```
```ruby
"HelloWorld"[0...2]
→ He
```
```ruby
"HelloWorld"[1..4]
→ ello
```
```ruby
"HelloWorld"[1...4]
→ ell
```
如果一个索引值是正值，则字符位置是从字符串的左侧开 始的。如果是负值，则从右侧开始。如图2.2所示。
![1](/img/Ruby/Chapter_02/2.png)
<center>图2.2 字符串正负索引的位置</center>

下面的命令演示了如何用负索引来获得子字符串:
```ruby
"HelloWorld"[-10..-6]
→ Hello
```
```ruby
"HelloWorld"[-3...-1]
→ rl
```
此外，你也可以使用第一个字符的索引值和子字符串的长 度来得到一个子字符串，格式是 [索引值, 长度]。下面的例子 介绍了如何在代码中使用:
```ruby
"HelloWorld"[3, 4]
→ loWo
```
```ruby
"HelloWorld"[0, 5]
→ Hello
```
```ruby
"HelloWorld"[-5, 5]
→ World
```

### 2.3.3 高级字符操作
除了目前为止介绍的操作外，你还可以通过在字符串后跟上点和方法来达到目的，方法将在本章后面解释。但现在，你可以把方法想象为一个具有特定名称的操作。比如，长度和大小是返回字符串中的字符数的两种方法。下面的例子介绍了如何在代码中访问这两种方法:
```ruby
"HelloWorld".length
→ 10
```
```ruby
"HelloWorld".size
→ 10
```
表2.3 中列出了长度、大小以及一些其他的字符串方法各 自的用途和使用示例描述。在 Ruby 文档网站可以找到字符串 类和其他基本 Ruby 类的更多方法: [http://www.ruby-doc.org/core/classes/String.html](http://www.ruby-doc.org/core/classes/String.html)。

| 操作      | 描述    |  范例 |
| --------- | -------- | ----- |
| downcase | 将所有字母转为小写  | "Hello".downcase → "hello" |
| hex | 将16进制表达式转为数字 | "0x42".hex → 66 |
| include? | 确定字符串是否包含指定的值 | "hello".include? "ell" → true |
| index | 字符串第一次出现的索引位置 | "Hello".index("e") →2 |
| length | 字符串的长度 | "Hello".length →5 |
| lstrip | 删除字符串前的空格 | " Hello ".lstrip → "Hello " |
| replace | 替换字符串 | "Hello!".replace("Hola!") → "Hola!" |
| reverse | 反转字符串的字符 | "Hello".reverse → "olleH" |
| rrindex | 字符串最后一次出现的索引位置 | "Hello".rindex("l") →3 |
| size | 字符串的长度 | "Hello".size →5 |
| split | 将字符串分割成子字符串，返回数组 | "Hello,world,again".split(",") →["Hello","world","again"] |
| strip | 删除字符串前后的空格 | " Hello ".strip → "Hello" |
| to_f | 如果可能，将字符串 转为浮点值并返回 | "-1.3e10".to_f → -13000000000.0 |
| to_i | 如果可能，将字符串转为整数值并返回 | "2000".to_i → 2000 |
| tr | 替换指定的字符 | "Hello".tr("le","ma") → "Hammo" |
| upcase | 将所有字母转为大写 | "Hello".upcase → "HELLO" |

<center>表2.3 字符运算</center>

### 2.3.4 输出字符串
Ruby 提供了三个命令，用于在控制台中显示字符串:puts、print 和 printf。本书中的示例代码主要使用 puts，可以 输出字符串并且换行。以下示例介绍如何使用 puts:
```ruby
puts "Number of characters in Hello: " + "Hello".length.to_s
→ Number of characters in Hello: 5
```
使用 to_s 方法将 “Hello” 的长度数值转换为了“字符串”。 Ruby 并不会直接将数值读取为字符串，因此必须使用代码进行转换。

print 命令与 puts 执行的操作相同，但不会在字符串末尾换行。Printf 命令和 print 几乎一样，唯一的不同是允许你使用特殊格式的字符。Printf 的格式是一个复杂的课题，这里就不 再深入讨论。但是，通过下面的例子你应该能想到如何使用它:
```ruby
printf "The length of %s is %d\n", "Hello", "Hello".length
→ The length of Hello is 5
```
```ruby
printf "The last index of b in bubble is %d\n", "bubble".rindex("b")
→ The last index of b in bubble is 3
```
Ruby 的 printf 与C语言中的 printf 命令完全一样。你可以 在互联网上搜索，那里将会介绍所有不同格式的命令和选项。

## 2.4 变量和常量
到目前为止，我们一直在处理纯粹的数字和文字。但在现 实世界中，我们都会给数据指定名称，并且对名称进行操作而不是原始数据。在 Ruby 中，可以指定的数据有两类:变量和 常量。本节将探讨如何使用它们以及它们之间的差异。
### 2.4.1 变量(Variables)
在 SketchUp 脚本中，使用名称比纯粹的数字更方便。例如，如果你想把一个门的高度从86英寸改为94英寸，你肯定 不想去手动把出现的每个“86”改为“94”。然而，更容易 的方法就是使用一个名称，如 door_height。现在你可以设置 door_height 为 94 来改变所有的高度值，此值在未来所有出 现的地方都适用。

让我们来看看它是如何在 SketchUp 中实现的。在 Ruby 控制台中，用下面的命令指定变量 x 的值为2:
```ruby
x=2
```
当你这样做时，SketchUp 会留出一部分内存给变量 x 并 把数值 2 放入这部分内存中。现在你就可以操作这个变量，只 要它是一个有规律的数值。例如:
*   x+5返回7
*   x * 2 返回 4
*   x**3返回8

在这些操作中，x 在每个命令中都保持它的初始值。如果 要改变一个变量的值，你可以执行如下操作:
*   x=x+1
*   x=x–3
*   x=x*7
*   x=x/9

你可以使用 Ruby 的简写运算符，来实现相同的结果:
*   x+=1
*   x-=3
*   x*=7
*   x/=9

这些操作都是基于整数的，但如果你愿意，你可以设置 x 等于一个浮点数或字符串。例如，以下命令将创建一个变量，其中包含 “Hello” 并使用字符串加法运算符来添加另一个字符串:
```ruby
str = "Hello"
→ Hello
str += ", world!"
→ Hello, world!
```
变量名 x 和 door_height 都有一个重要特征:都以小写字 母开头。在 Ruby 中，一个变量可以用下划线或任何小写字母 开头，但不能是一个大写字母。如果数据被指定为一个大写字母开头的名字，Ruby 会将其识别为一个常量，这就是下面将要解释的内容。
### 2.4.2 常量(Constants)
在很多情况下，我们会处理一些不会变化的值。比如 π始终约等于 3.14159，2.54 厘米始终等于1英寸。在这些情况 下，使用变量并不是一个好办法， 因为它的值在执行的过程 中可能会改变。

出于这种原因，Ruby 提供了常量，操作类似于变量并且 可以被指定成相同类型的值。如果一个常量的值被重新指定， Ruby 会发出一个警告，告诉你它的值已经被改变。要弄明白 这些是如何工作的，请在控制台窗口中输入以下二个命令:
```ruby
X=8
X += 2
```
执行这些命令后，如图2.3，在 Ruby 控制台中出现提示: "already initialized constant X"(常量 X 的值已被初始化)。
![1](/img/Ruby/Chapter_02/3.png)
<center>图2.3 更新常量的值</center>

尽管会产生警告，但第二个命令已将 X 的值从8改为10， 你可以自行进一步验证。

如果你用 x 代替 X 重新执行这些命令，将不会出现警告。 这是因为 Ruby 使用数据结构的第一个字母来区分常量和变量。 如果第一个字母是大写，Ruby 会认为它是一个常量，如果是 小写，则为变量。

## 2.5 数组(Arrays)
在 SketchUp 模型中的每个点、线和形状必须用x，y和z 坐标来定位。将坐标放在一个数组中比使用单独数字进行管理 要方便的多。

数组是一种数据结构，包含一个称为元素的有序序列数值。 数组看起来和前面讲过的字符串类似，但是字符串是由字符组 成的，而数组可以包含任何东西，比如数字、字符串、变量、 常量，甚至其它数组。

正如字符串放在单引号、双引号内一样，数组需放在方括 号内。例如，下面将创建一个7个元素的数组:
```ruby
arr = [1, 2, "ab", 4.0, 'Hello', 6.0, [1, 2, 3]]
```
这将创建数组 arr，包含的元素有1、2、"ab"、4.0、 'Hello'、6.0和 [1, 2, 3]。
### 2.5.1 访问数组元素
对元素的访问，是依据其在数组的内部位置，从0开始。一个元素的位置称为其索引。下面的命令，访问 arr 数组中索 引为 2 的元素:
```ruby
x = arr[2]
```
下面的命令设定数组中第四个元素(索引为 3)的值:
```ruby
arr[3] = 12
```
数组元素的索引与字符串中字符的索引遵循相同的规则。 索引 0 表示第一个元素，索引 1 表示第二个元素，索引 2 表 示第三个元素。负的索引从数组的末尾开始访问元素，也就是 说，索引 -1 返回数组的最后一个元素值，-2 返回数组的倒数 第二个元素值等等。

和字符串一样，你可以通过定义一个索引的范围来访问多个数组元素。方法是在起始值和结束值之间放两个或者三个点。 下面的命令访问之前定义的 arr 数组中的元素:
```ruby
arr[2..5] 
→ ["ab", 4.0, "Hello", 6.0]
```
```ruby
arr[0...3] 
→ [1, 2, "ab"]
```
```ruby
arr[-6..-4] 
→ [2, "ab", 4.0]
```
或者你也可以设置一个起始索引值，找出随后的几个元素 形成子数组。下面的命令将形成一个子数组，从索引 2 开始的 4 个元素:
```ruby
x = arr[2, 4] 
→ ["ab", 4.0, "Hello", 6.0]
```
这个命令将设置包含"ab", 4.0, "Hello"和 6.0 的数组等于 x。 当你遇到任何跟范围相关的错误时，请记好 [2..4] 和 [2, 4] 的 区别。
### 2.5.2 基本的数组操作
Ruby 提供一些不同的方法来操作数组，其中许多是完全类似于字符串的操作。表2.4 列出 6 个数组操作符的说明及用 法:

| 符号      | 注释    |  范例 |
| --------- | -------- | ----- |
| + | 合并两个数组 | [6, 7] + ["aa", "bb"] → [6, 7, "aa", "bb"] |
| - | 从第一个数组中删除第二个数组包含的元素 | [1, 2, 3, 4] – [1, 2] → [3,4] |   
| * | 重复数组中的元素 | [a, b] * 3 → [a,b,a,b,a,b] |  
| << | 在数组末尾追加元素 |  [x, y, 12] << 13 → [x, y, 12, 13] |  
| &#124; | 合并重复的元素 | [1, 2, 3] &#124; [2, 3, 4] → [1,2,3,4] |  
| & | 保留重复的元素 | [1, 2, 3] & [2, 3, 4] → [2,3] |  

<center>表 2.4 Ruby 数组运算</center>

在第三列中，数组元素包括引号括起来的文本名称( ”aa” 和”bb”)和不带引号的字母(x、y)。如前所述，不带引号的 名称用来识别变量和常量，并且必须在它们插入数组之前初始 化。

第三个运算符“*”，当你初始化一个含有相同值的数组 中的每个元素时，特别有帮助。例如下列的代码将 zero_array 数组填充为12个零:
```ruby
zero_array = [0] * 12
```
“<<” 运算符可在数组的末尾追加一个元素。如果第二 个参数是另一个数组，则该数组将成为第一个数组中的一个元 素。例如，命令:
```ruby
[1, 2, 3] << [4, 5, 6]
```
返回 [1, 2, 3, [4, 5, 6]]，而不是 [1, 2, 3, 4, 5, 6]。 如果你 要追加的是第二个数组中的元素，你可以使用下节的 concat 方法。

最后两个运算符容易混淆。“|”运算符是将数组连接在 一起，移除重复的串联，也就是说，如果两个数组都包含 x 和 y，结果将只包含一个 x 和 y。“&” 运算符创建一个由重复 元素组成的数组。如果 x 和 y 是数组中重复的元素，& 运算结 果将只包含 x 和 y 。
### 2.5.3 数组方法
Ruby数组有类似于前面字符串调用的方法。表2.5 列出12个重要的方法，其他方法也会在需要时进行介绍。

| 方法      | 注释    |  范例 |
| --------- | -------- | ----- |
| new | 创建一个新数组 | num_list = Array.new(30) |
| length | 返回数组中元素的数量 | [1, 2, 3, 4].length → 4 |   
| index | 返回给定元素的索引值 | [1, 2, 3].index(1) → 0 |  
| concat | 连接两个数组 | [1, 2, 3].concat([4, 5]) → [1,2,3,4,5] |  
| delete_at | 按索引值移除元素 | a.delete_at(1) a → [1,3] |  
| delete | 按元素值移除元素 | a = [1, 2, 3] a.delete(1)a → [2,3] |  
| clear | 清空数组 | ["a", "b", "c"].clear → [] |
| uniq | 移除重复的元素 | [1, 1, 2, 2, 3].uniq → [1, 2, 3] |
| fill | 替换数组中元素的值 | [1, 2, 3].fill(7) → (7, 7, 7) |
| sort | 对元素进行排序 | ["ab", "yz", "wx","ac"].sort → ["ab", "ac", "wx", "yz"] |
| first | 返回数组中第一个元素 | [1, 2, 3].first → 1 |
| last | 返回数组中最后个元素 | [1, 2, 3].last → 3 |

<center>表 2.5 Ruby 数组的方法</center>

方法“new”可用三种不同的方法来创建新的数组，如下面例子所示:
1. num_list = Array.new 20
创建一个给定大小但没初始化元素的数组。
2. num_list = Array.new 4, "xyz“
创建一个有四个元素的数组，每个元素值为“xyz”。
3. num_list = Array.new old_list
创建一个与数组old_list相同元素的新数组。

length 方法确定数组中有多少元素， index 返回与给定元 素值相关联的位置。这是数组通常的反向用法，它返回与索引 相关联的元素值。

concat 方法类似于 表2.4 中的 + 运算，把一个数组的元 素添加到第二个数组的末尾。所不同的是， + 运算创建第三个 数组来存储合并的结果，而 concat 则是修改第二个数组。下 列命令将介绍如何使用:
```ruby
first_array = [5, 4, 3, 2, 1]
```
```ruby
second_array = [8, 7, 6].concat(first_array)
```
第二个命令追加 first_array 的元素到 second_array 的末 尾，相当于目前 second_array 为 [8, 7, 6, 5, 4, 3, 2, 1]。

delete_at 和 delete 方法都是删除数组中的元素，但以不 同的方式操作。 delete_at 是按特定的索引值来删除元素， delete 方法则是删除某特定值的所有元素。以下命令介绍如何 使用这两种方法:
```ruby
test = [10, "x", 9, "x", 8, "y", "x"]
```
```ruby
test.delete_at 4 
→ test = [10, "x", 9, "x", "y", "x"]
```
```ruby
test.delete "x" 
→ test = [10, 9, "y"]
```
delete_at 方法删除数组中的第五个，值为8元素。delete 方法删除值为 "x" 的所有元素。

uniq 方法是从数组中移除重复的元素， clear 方法是移除 数组中的所有元素。 fill 是设置数组元素为给定值，主要以四 种方式使用，如下命令所示:
```ruby
fill_test = [1, 2, 3, 4, 5, 6]
fill_test.fill 9                 #设置所有元素值等于 9
fill_test.fill 10, 0..2       #设置第1到3的元素值等于 10
fill_test.fill 21, 4, 2       #设置从元素4开始的2个元素等于 21
```
sort 方法按数字或者字母顺序对数组元素进行排序，但只 有当所有的元素都是数字或者字母时才有效。first 和 last 返回 数组的第一个和最后一个元素，可以通过访问索引值 0 或 -1 来代替。

## 2.6 对象、类和方法
在计算机编程的初期，存储数据的唯一途径是创建变量、 常量、字符串和数组。但随着时间的推移和应用程序复杂性的 增长，管理数以千计的编码太混乱，程序员逐渐厌倦了。于是 他们决定把相关的数据和操作分组到称为对象的结构中。在一 个对象中的数据和操作的本质是对象的类，在类中定义的操作 称为它的方法。

整本书一直在写面向对象的编程问题，所以本节中对 Ruby对象的介绍篇幅较短。更多详细的信息，我建议您阅读 Grady Booch、Robert A. Maksimchuk、Michael W. Engel和 Bobbi J.Young 的著作《Object-Oriented Analysis and Design with Applications》。另外，在网络上有很多免费资源讨论面 向对象程序设计。
### 2.6.1 对象(Objects)
在 SketchUp 中要建立一个大型的模型，你需要指定许多特性，包含坐标、材质、纹理和颜色等，访问设计窗口很容易 就可以对这些进行设置:点击线时，SketchUp 会告诉你它的 长度。但对于软件来说，管理这么多的数据是一项艰巨的任务。

为了使我们更容易接受，我们把相关的数据分层组织到数据结构里。例如，如果我们建一个房子的模型，我们将为房子创建一个总体数据结构，而较低级别的子结构包含它的墙壁、门窗和屋顶等。一个门的子结构可能包含子-子结构，包含门 的拉手、锁和门板等。

在软件中，这些数据结构称为对象。一个对象就像我们之 前讲过的变量一样可以被访问。但又区别于变量，一个对象可 以包含多个相关的值。例如，当用 door_height 来确定门的高 度，一个 Door 的对象可能还包含高度、宽度、厚度、材料和 颜色等。

用数组来对比理解对象是很有帮助的。在 Ruby 中，数组 可以包含任何类型的元素，但对象只包含建模需要的数据—— 物理对象或者抽象原则。例如，如果要设计一个房子，您需要 记录每个门的高度、宽度和材质，然后将这些值存储在门类型 的对象中。设计还可能包括窗户、门廊和车库类型的对象等。 两个相同类型的对象必须具有相同的特征，但不一定有相同的 值。如果门类型中定义了高度和宽度，对象door1和door2都是 门类型，door1和door2必须存储高度和宽度值——但不一定是 相同的值。

描述一个对象类型的特定术语是它的类。理解对象和类之
间的关系很重要，这是以下讨论的重点。
### 2.6.2 类(Classes)
类定义对象的结构就相当于一套蓝图定义建筑物的结构或者 DNA 链定义生物体的结构。更具体地说，一个类可识别包 含在对象和方法内的数据用于操作对象中的数据。

关于新建类的内容不得不等到第8章。现在，你只需要知 道什么是类，以及怎么从存在的类中去创建对象。在 Ruby 库 和 SketchUp API 之中，有数百个可用的类。

在 Ruby 中，我们工作用到的所有东西都是对象。因此， 我们工作用到的所有东西都有类。class 方法用来显示对象的 类的名称，如下面代码所示:
```ruby
5.class 
→ Fixnum
```
```ruby
3.14159.class 
→ Float
```
```ruby
"Hello, world".class 
→ String
```
```ruby
[5, 6, 7].class 
→ Array
```
如图所示，5 是 Fixnum(定长整数)类的对象，3.14159 是Float(浮点数)类的对象，"Hello, world" 是 String(字符 串)类的对象以及 [5, 6, 7] 是 Array(数组)类的对象。如果 你分析别人的代码，类的方法可以更精确地确定你正在处理的 数据类型。

Fixnum, Float, String 和 Array 类，都是 Ruby 标准库提 供的。但我们在这本书中的重心是 SketchUp API。下面两个 特别重要的将在下一章讨论:
*   Edge —— 从 Edge 类中创建的对象用来描绘在 SketchUp 设计中的线段。
*   Face —— 从 Face 类中创建的对象用来描绘在 SketchUp 设计中的二维面。

注意:不是使用词语 “从 Face 类中创建的对象”或者 “Face 类型的对象”，这本书将这些对象称为面对象或者面。 但要记住，Face 是类的名称，而不是对象名称。

在附录 A 中列出有超过 80 个不同的 SketchUp API。您 还可以访问[http://www.sketchup.com/intl/en/developer/docs](http://www.sketchup.com/intl/en/developer/docs)网站，在那里，你可以通过点击链接来查看每个类如何使用。
### 2.6.3 实例方法(Instance Methods)
在前面的字符串讨论中，解释了基本的运算符 + 和 * ，也列出了一系列称为方法的操作。这些方法操作在字符串对象 上——如果 str 是一个字符串，str.length 返回 str 中的字符数。 同样，str.downcase 转换所有字符为小写。如果想列出 String 的所有方法，在 Ruby 控制台中输入以下命令:
```ruby
"Hello".methods
```
这里列出了一个 String 对象的所有可用的方法。如果 str 是一个字符串变量，你可以通过调用 str.methods 来完成相同 的结果。这些方法定义在 String 类中，所有的 String 对象， 比如 str，都可以调用它们。

Array 类为它的对象提供了另一套方法，如下所示:
```ruby
arr = [0, 1, 2]
```
```ruby
arr.length 
→3
```
```ruby
arr.first 
→0
```
```ruby
arr.last 
→2
```
方法是定义在操作于对象数据的类中的过程。简而言之， 一个对象代表一个事物，一个方法提供一种与事物的特征交互 的手段。方法可通过点表达式被调用，点表达式是对象后跟着 一个点和方法名。例如，如果 Auto 类定义一个 reverse 的方 法，auto1 和auto2 都是 Auto 的对象，那么你可以调用 auto1.reverse 和 auto2.reverse。

许多方法都需要额外的数据来操作。在 表2.5 中，Array 类中的 fill 方法需要一个输入值，以取代数组元素的值。这种 额外的数据，称为 argument 或者 parameter(参数)，可以 带或者不带括号。如下命令所示:
```ruby
arr = [0, 1, 2, 3]
```
```ruby
arr.fill(7) 
→ [7,7,7,7]
```
```ruby
arr.fill 7 
→ [7,7,7,7]
```
如果方法需要多个参数，参数必须用逗号隔开，无论参数列表外边有没有括号。

附录A 列出 SketchUp API 中定义的每个类的方法。如果 你仔细观察，你会发现有很多方法名称结尾用 ? 号，也有一些 用 = 号结束，可能你会有一个疑问是:它是如何工作的。如果 该方法以 ? 结束，将返回 true 或 false。例如，String 类的 include?方法，如果参数是 String 的一部分，返回 true;否则 返回 false。比如下面的例子:
```ruby
str = "Hello, world"
```
```ruby
str.include? "ell" 
→ true
```
```ruby
str.include?("word") 
→ false
```
如果一个 Ruby 方法以 = 号结束时，它将用参数提供的数 据来更新对象。使用 Array 类的 []= 方法可以论证，改变数组 元素的值为那个参数，以下代码将使第三个元素的值等于 5。
```ruby
arr[2] = 5
```
uby 方法可以链接在一起使用，也就是说，如果 method_B 可以去操作 method_A 返回的值，你可以这样调用 两种方法: method_A.method_B。假设你要将 ”hello” 颠倒并 转换为大写字符，你可以使用多个命令，如下所示:
```ruby
str = "Hello"
```
```ruby
str1 = str.upcase 
→ HELLO
```
```ruby
str2 = str1.reverse 
→ OLLEH
```
或者你也可以在一个命令中完成相同的结果:
```ruby
str = "Hello".upcase.reverse 
→ OLLEH
```
在这个例子中， reverse 方法运算在 “Hello”.upcase 的结 果上。方法链减少你需要输入的代码量，但会降低代码的可读 性。
### 2.6.4 类方法(Class Methods)
前面的讨论意味着在一个类中定义的所有方法，只能通过对象来访问。这是经常出现的情况，但它并不完全正确。一些类的方法可以操作其本身，操作类的方法称为类方法。操作对象的方法，称为实例方法，因为对象是类的实例:
```ruby
new_str = String.new
```
```ruby
new_str.class
→ String
```
在本书中，我们将使用的方法绝大多数是实例方法。除非特别说明是类方法，本书中所讨论的任何方法，都可以假定为一个实例方法。

## 2.7 类的继承
在许多情况下，你需要访问一些有共同特征的类。如果你 是一名建筑师，你可能需要建酒店或者医院的模型。两者的结 构是不同的，需要单独的类: Hotel 和 Hospital。但是，这两 种类包含了相似的特征，如位置、材料和楼层数。出于这个原 因，下列方法无论在 Hotel 或者 Hospital 都同样适用:
*   num_stories —— 结构中的楼层数
*   location —— 结构的地理位置
*   material —— 结构使用的材质类型

除了两次使用相同的代码，更有效的做法是把他们放在第 三个类中提供给 Hotel 和 Hospital 对象。第三个类要体现 Hotel 和 Hospital 这两个类的共性，在这个例子中，我们称之 为 Building 类。同样我们会建立 Building、Hotel 和 Hospital 之间的关系，Hotel 和 Hospital 就会接受在 Building 中定义的 方法。

类之间的这种关系被称为继承，可以说 Hotel 和 Hospital 都继承了 Building 类。在这个例子中，Building 是 Hotel 和 Hospital 的 superclass(父类)，Hotel 和 Hospital 称为 Building 的 subclasses(子类)。图2.4 介绍了类继承的层次结构:
![1](/img/Ruby/Chapter_02/4.png)
<center>图 2.4 简单的继承层次结构的示例</center>

现在你可以定义一个单独的 Building 类的 num_stories, location 和 material 方法，如果你需要重写其中的任何一个， 你只需要修改一个单独的类。此外，通过创建 Building 类，你 可以很容易地添加更多的类来代表图书馆、教堂和商店等建筑。

让我们来看看一个现实世界中类的继承的例子。Ruby 解 释器处理数字根据它们占用内存的不同而不同。如果一个整数 占31字节或者更少，那么它是 Fixnum 对象。如果一个整数占 超过31个字节，这是 Bignum 对象。这就是为什么 24.class 返回 Fixnum 和 1234567890.class 返回 Bignum。

出于这个原因，Ruby 有一个专门为整数的类，称为 Integer 类。通常的方法比如 next 都放置在 Integer 类中，因 为 Fixnum 和 Bignum 都从 Integer 继承，该方法适用于这两 个类的对象。图2.5 显示 Integer、Fixnum 和 Bignum 在 Ruby 中 Numeric 类的层次结构。
![1](/img/Ruby/Chapter_02/5.png)
<center>图 2.5 Ruby Number 类继承关系</center>

在第8章将会阐述如何用代码创建类和子类。但现在，关 于类的继承，你必须了解的是:如果类 B 从类 A 继承(即类 A 是类 B 的父类)，那么类 A 中的所有方法在类 B 中都可以 使用。这就意味着，任何类 B 的对象都能访问类 A 对象中的 方法。

## 2.8 结论
本章的目的是使你在 Ruby 的基础上，了解 SketchUp 的对象，以及它们是如何在代码中使用的。本课从数字、字符串、数组、变量和常量开始讨论，然后解释对象和类。这些数据结构将贯穿本书。

如前所述，你可以把一个对象想象为一个事物，一个对象 的方法就是与事物交互的一种手段。在 Ruby 中，每一个数据 结构都是一个对象，包括数字和变量。数字 5 具有Ruby方法， 可以使用与字符串或者数组相同的点表达式来调用。

类定义对象的结构，包括对象的数据和操作对象的方法。 有些方法可以使用参数，在 Ruby 中，这些参数可以选择是否 由括号包围。如果有多个参数，必须用逗号分隔。一些方法， 被称为类方法，操作于类而不是对象。这里最重要的是 new ， 可以从类中创建一个新的对象。

面向对象编程是一个复杂的话题，如果你搞不清它，不必担心。通过这本书的范例及现成的代码，你就可以弄明白面向对象的编码原则。 

在下一章中，我们将抛开理论问题来看看 SketchUp 的对 象是如何协同工作并创建三维模型的。


# 第5章 Ruby课程＃2：控制结构和文件
本章主题
* [Ruby条件处理：if-else和case](Ruby条件处理：if-else和case)
* [处理循环：while，until和for](处理循环：while，until和for)
* [迭代器和代码块](迭代器和代码块)
* [Ruby/SketchUp文件访问](Ruby/SketchUp文件访问)

本章简要介绍了Ruby的两个中间特性:控制结构和文件访问。第一个主题涉及使用条件控制代码执行并使用循环重复执行代码。第二个主题涉及与文件有关：如何创建文件，写入文件，从中读取文件以及删除文件。此讨论还解释了Ruby目录访问和SketchUp特定的文件访问。

## 5.1 条件处理：if和case
到目前为止，我们遇到的每个Ruby脚本都是纯粹顺序执行的。也就是说，执行第一个命令，然后执行下一个和下一个命令，依此类推，直到脚本结束。但通常，您需要使用条件来确定是否应执行某些命令。例如，如果一个模型位于xy平面中，您可能希望脚本执行一组命令，如果模型不在，则可能需要另一组命令。

Ruby提供了两种主要的方法来建立这些条件：if语句和case语句。if语句检查条件是否为真，如果为真，则执行if语句后面的命令。case语句检查变量并根据其值执行不同的命令。

### 逻辑操作和if语句
  本书中的第一个Ruby课程解释了数字和数字运算符。在Ruby中，数字运算符接受一个或两个数字并返回一个数字。现在我们将看一个新的运算符：逻辑运算符。打开SketchUp的Ruby控制台并输入以下命令：
```ruby
20 > 10
```
按Enter键，显示的结果为真，因为20大于10。现在试试这个：
```ruby
"S" == "E"
```
按Enter键，结果将为否，因为“S”不等于“E”。  

在Ruby中，true和false是逻辑运算符生成的值。表5.1列出了>，==和其他类似的运算符。第三列中的用法示例始终返回真。

表5.1
Ruby逻辑运算符

| 操作      | 描述    |  用法范例 |
| --------- | -------- | ----- |
| == | 等于  | 6 * 8 == 48 |
| != | 不等于 | "J" != "X" |
| != | 不等于 | "J" != "X" |
| < | 小于 |  24 < 30 |  
| > | 大于 |  B" > "A"|  
| <= | 小于或等于 | 22 <= 22 |    
| >= | 大于或等于 | "X" >= "W" |    
| ! | Boolean NOT | "X" >= "W" |   
| && | Boolean AND | 3 * 5 == 15 && 5 * 2 == 10 |   
| &#124;&#124; | Boolean OR | "A" == "A" &#124;&#124; "J" == "K" |   

当与Ruby的if语句结合使用时，逻辑运算符就能大显身手了。该语句首先测试逻辑操作的结果。如果操作未返回false或nil，则if语句后面的命令将执行到end关键字。如果操作返回false或nil，则跳过if语句后面的命令。以下代码提供了一个简单示例：
```ruby
if 6 * 8 == 48
 puts "6乘以8等于48。"
 puts "因此，本声明将被输出。"
end
```
如果将这些行放在Ruby脚本中并执行脚本，则逻辑操作返回值为真。因此，将执行if和end之间的命令，并且控制台将显示两行文本。

如果在脚本中执行以下代码，则逻辑操作将返回值为否。这意味着将不执行if和end之间的命令。
```ruby
if "M" <= "F"
 puts "此声明不会被输出。"
end
```
注意！表5.1中的运算符反转逻辑运算的值，将真变成为假，将假变成为真。此操作必须用括号括起来，如下面的代码所示：
```ruby
if !(6 * 8 == 48)
 puts "!运算符使条件为假。"
 puts "这些文本行不会显示。"
end
```
&&和||运算符组合两个逻辑运算的结果以返回单个结果。仅当两个操作都返回值真时， &&运算符才返回真。如果一个或两个操作都返回真， ||操作符返回真。

以下陈述说明了这些运算符在实践中的运作方式。各个逻辑操作不必括在括号中，但我发现它使代码更容易阅读。
```ruby
if ("B" > "A") || (14 == 9 * 2)
 puts "第一个表达式为真，但第二个表达式为假。"
 puts "因此，||运算符返回真。"
 puts "将显示这些语句。"
end
if ("B" > "A") && (14 == 9 * 2)
 puts "第一个表达式为真，但第二个表达式为假。"
 puts "因此，&&运算符返回假。"
 puts "不会显示这些语句。"
end
```
 if语句可用于确定对象是否存在。假设您尝试使用Entities类的add_face方法创建Face对象：
 ```
 face = Sketchup.active_model.entities.add_face p1, p2, p3
 ```
 如果方法成功完成其操作，则face将是Face对象。如果没有，face将为nil。在Ruby中，nil表示对象未成功创建，或者更确切地说，对象不存在。if语句以相同的方式响应nil和false。以下代码测试face是否存在：
```ruby
if face
 puts "如果可能读取到此信息，add_face成功完成。"
 puts "否则，face就等于零，您就不能看到到此信息"
end
```
### if..else和if..elsif..else语句
只要条件既不是假也不是零，if语句都会执行命令。当if语句后跟else时，当条件返回false或nil时，将执行不同的命令集。可以这样想：如果条件有效，告诉处理器走一条路 - 如果条件无效，则告诉处理器采用另一种方式。

例如，以下代码测试是否已成功创建new_edge对象。

如果是这样，会显示消息成功！。如果没有，则会显示消息为零！。
```ruby
if new_edge
 puts "消息成功!"
 else
 puts "为零!"
end
```
if和else之间的命令以及else和end之间的命令将永远不会被执行。将执行第一组或第二组，但不执行两者。

if..else语句可以嵌套在另一个if..else语句中以测试多个条件。这显示在以下代码中：
```ruby
if x > 5
 puts "x大于5。"
else
 if x < 5
 puts "x小于5。"   
 else
 puts "xx等于5。"
 end
end
```
嵌套的if..else语句可能变得混乱，尤其是在添加越来越多的条件时。出于这个原因，Ruby提供了一个if..elsif..else语句，使生活更轻松。

这显示在以下代码中：
```ruby
if day < 7
 puts "第一周。"
elsif day < 14
 puts "第二周。"
elsif day < 21
 puts "第三周。"
elsif day < 28
 puts "第四周。"
else
 puts "第四周之后。"
end
```
如图所示，elsif的行为与if一样，您可以根据需要添加尽可能多的elsif语句。

在Ruby中，if语句返回的值等于其上次执行的命令的值。这与许多其他语言中的if语句明显不同，后者根本不返回任何值。理解这一点的最好方法是看一个例子：
```ruby
result = if 3 * 4 == 12
 "truth"
end
```
在这种情况下，最后执行的命令只是“truth”。因此，因为逻辑条件有效，所以结果设置为“真值”。清单5.1显示了if..elsif..else语句的返回值如何将变量的值设置为许多备选方案之一。

Listing 5.1：season.rb
```ruby
m = Time.new.month # 获取当前月份
Hemisphere s = if m < 4 # 设s等于北半球当前的季节
 "冬天"
elsif m < 7
 "春天"
elsif m < 10
 "夏天"
else
 "秋天"
end
puts s #显示s的值
```
您可以根据需要添加尽可能多的elsif选项，但Ruby提供了一种更方便的方法来检查代码中的多个条件。这是通过case语句完成的，将在下面讨论。

### case语句
与Listing 5.1中的if..elsif..else语句一样，case语句中执行的命令取决于变量的值。case语句以case开头，通常后跟一个变量名。接下来，在变量的不同可能值之前加上关键字when。如果该变量等于所列出的任何值，则执行后面的命令将执行，直到替换或最终结束时的下一个命令。

如果这看起来令人困惑，代码示例应该清楚。以下案例声明检查字母并根据其值输出不同的字符串。
```ruby
case letter
 when "A"
  puts "第一个字母"    
 when "M", "N"
  puts "中间的字母"   
 when "Z"
  puts "最后一个字母"
end
```
第二个when选项测试字母值对两个值，用逗号分隔。case语句还可以测试变量的值是否落在值的范围内，如以下代码所示：
```ruby
case temp_in_C
 when -273
  puts "Absolute zero"   
 when -273..20
  puts "Cold"
 when 20..25
  puts "Comfortable"    
 when 25..10_000
  puts "Hot"
 else
  puts "You must be joking!"
end
```
最后的else语句提供了一个包罗万象的选项。如果没有执行任何先前的命令，则case语句将输出"您一定是在开玩笑!"到显示屏幕。

需要提到case语句的最后两个特性。首先，与if语句一样，case语句返回其上次执行的命令的值。其次，可以在将命令放在同一行之后插入Word。因此，前面的代码示例可以重写如下：
```ruby
ans = case temp_in_C
 when -273  then "Absolute zero"
 when -273..20  then "Cold"
 when 20..25 then "Comfortable"
 when 25..10_000 then "Hot"    
 else "You must be joking!"
end
puts ans
```
与之前的when选项不同，else选项不需要then。catch-all命令可以直接放在同一行上。

## 5.2 处理循环：while，until和for
Ruby的while，until和for语句称为循环语句或循环，因为它们可以重复执行一组命令。当您需要处理数组的每个元素或反复申明范围中的每个值时，循环语句变得至关重要。例如，如果您需要变换100个数组中的每个顶点，则可以（并且应该）使用循环来代替一百个单独的命令。

### while和until循环
正如if语句根据逻辑操作执行命令一样，只要逻辑操作返回true，Ruby的while语句就会重复执行命令。这显示在以下代码中：
```ruby
x = 5
while x > 0 # 持续循环直到x > 0
 print x, " "  # 输出x的值
 x -= 1 # 将x的值减1
end
```
如果将此代码放在脚本中并执行它，控制台将显示：5 4 3 2 1。

x最初等于5，因此x> 0返回true并执行循环内的两个命令。第二个命令将x从5减少到4，然后再次执行x> 0操作。x> 0操作返回true五次，但在第五次重复执行后，x等于零。在这种情况下，x> 0操作返回false并且循环终止。
```ruby
x = 5
while x > 0 # 永不不会停止，因为x的值没有发生改变
 puts "循环进行中!"
end
```
永不结束的循环称为无限循环。这通常是错误的结果。

Ruby的until语句就像while语句一样，但功能相反。如果逻辑操作返回true，则while循环执行命令，并继续执行命令，直到操作返回false。until循环执行相反的操作：如果操作返回false，它将开始执行命令并继续执行它们，直到其操作返回true。

该例子将阐明其工作原理。以下直到循环开始，因为y不等于“E”。循环中的第二个命令将y设置为等于其下一个字母（“A”到“B”，“B”到“C”，依此类推），循环继续，直到y等于“E”。也就是说，循环继续，直到逻辑操作y ==“E”返回true。
```ruby
y = "A"
until y == "E"  # 持续循环直到y = E
 print y, " "    
 y = y.next  # 设y等于下一个字母
end
```
如果将此代码放在脚本中并执行它，控制台将显示：A B C D。

在代码中是使用while语句，还是until语句其没有明确的准则。它们都有相同的用途，所以这完全是为了需求的方便。

### for循环
while和until循环重复执行命令，直到逻辑条件变为true或false。在Ruby中，只要变量位于给定范围内，for循环就会重复命令。在Ruby中，范围以两种方式之一指定：start..end或start ... end。第一个范围（有两个小数点）包括结束，但第二个范围（有三个小数点）则不包括。以下示例显示了这种区别：
```ruby
for count1 in 0..5
 print count1, " "
end
for count2 in 0...5
 print count2, " "
end
```
在第一个循环中，控制台显示0 1 2 3 4 5。在第二个循环中，它显示0 1 2 3 4.每个循环以for开头，以end结束。关键字in将变量与范围分开。

组成范围的值可以是整数或字符串，但不能是浮点值。 也就是说，“ABC”..“CBA”是for循环中可接受的范围，但不是0.0..5.0。也可以使用Ruby数组，如以下示例所示：
```ruby
alph_array = ["alpha", "bravo", "charlie", "delta"]
for aword in alph_array
 print aword, " "
end
```
输出结果将是alpha bravo charlie delta。

## 5.3 迭代器和代码块
到目前为止，我们所看到的构造（if，case，while，until，for）非常类似于其他语言（如C，C ++和Java）的构造。现在我们来看看迭代器和块，它们与C和C ++中的任何东西都不同。当我第一次学习Ruby时，我发现这些主题很难理解，但是我已经开始对Ruby的强大功能产生极大的赞赏。

Ruby迭代器是一种可用于数组和容器的特殊方法。迭代器执行与for循环基本相同的任务，但更容易使用。比较一下就清楚了。下面的代码遍历五个元素数组并输出每个元素的名称：
```ruby
for name in five_array
   p name
end
```
使用一行代码可以完成相同的结果：
```ruby
five_array.each {|element| puts element}
```
当执行这个命令时，each方法告诉Ruby解释器处理five_array花括号中每个元素中的语句。也就是说，它告诉解释器处理 {|element| puts element}五次。

由垂直线包围的名称是占位符 - 它在迭代器执行时接收每个数组元素的值。在这种情况下， five_array的每个后续元素将被称为element (元素)。因此，该命令为five_array的每个元素调用puts element，并输出元素的值。

在这个例子中，单词element没有什么特别之处，以下代码将完成相同的结果：
```ruby
five_array.each {|e| puts e}
```
在前面的代码中，each方法都称为迭代器，花括号内的语句称为代码块。当迭代器执行时，代码块对数组中的每个元素重复执行一次。但each不是Array (数组) 类中唯一的迭代器。其中最常用的三个如下：
1. collect - 更改数组中的每个元素并返回更新的数组

2. each_index - 将每个元素的索引放入占位符，而不是元素的值

3. find - 对每个元素应用逻辑运算，并返回返回值true的第一个元素

案例5.2中的代码演示了如何在代码中使用它们。我强烈建议您尝试使用它们以提高您的熟悉度。如果使用得当，迭代器可以为您节省大量的编码时间！

案例 5.2: iterator_demo.rb
```ruby
# 定义数组
five_array = ["one", "two", "three", "four", "five"]
# 输出元素索引
print "The array indices: "
five_array.each_index { |index| print index.to_s + " "}
# 将每个元素名称前改成大写，并添加上"o'clock"
five_array = five_array.collect { |name|
   name.capitalize + " o'clock"
   }
   # 输出新的元素名称
print "\n\nThe array elements: "
five_array.each { |name| print name + " "}
# 输出第一个字母小于“G”的元素
print "\n\nFirst element less than G: "
puts five_array.find { |name| name < "G"}
```
执行该脚本会产生以下结果：

数组索引：0 1 2 3 4
阵列元素：One o'clock Two o'clock Three o'clock Four o'clock Five o'clock
小于G的第一个元素: Four o'clock

在SketchUp中，迭代器和代码块特别重要，它将所有设计的模型，材质，图层和页面存储在类似
数组的容器中。下一节提供了迭代器如何使查找和处理SketchUp元素变得容易的示例。

## 5.4 迭代器和SketchUp集合
通过附录A，您会注意到SketchUp API中的许多类名称都是复数 如Entities, Materials, Pages, Layers, Styles, RenderingOptions等。这些集合可以作为数组访问，这意味着它们的元素通常可以使用像each这样的迭代器来访问。

迭代模型的Entities对象是一个常见的要求：您可能需要收集所有Vertex对象，隐藏所有边线，或找到在给定方向上具有法线点的Face。这些任务可以使用for循环执行，但是使用迭代器和块可以更简单地完成它们。本节介绍三个常见迭代任务的示例。

### 找到具有给定方向的面
假设你已经创建了一个有许多面和边的三维图形，并且您希望找到它的法向量指向正x方向的面。
1. 访问模型的Entities对象。

2. 对于每个元素，确定其typename是否等于Face。

3. 对于每个Face，确定其法向量是否等于[1,0,0]。

案例 5.3: find_face.rb
```ruby
# 创建模型
ents = Sketchup.active_model.entities
face = ents.add_face [-1, -1, 0], [-1, 1, 0],
   [1, 1, 0], [1, -1, 0]
face.pushpull 1
# 找到指向x方向的面
xface = ents.find {|ent| ent.typename == "Face" &&
   ent.normal == [1, 0, 0]}
puts "The face is: " + xface.to_s
```
find方法结合了两个比较。第一个检查Entity是否是一个面，第二个检查面的法线向量是否为[1,0,0]。您不能颠倒这些操作的顺序 - 如果您尝试获取非Face的Entity的法线向量，则会导致错误。

### 收集数组中的顶点对象
将SketchUp模型导出为其他格式时，通常会列出设计中的每个点。案例5.4创建了一个图形，遍历每条边，并找到它的顶点对象。

案例 5.4: find_vertices.rb
```ruby
# 创建图形
ents = Sketchup.active_model.entities
face = ents.add_face [-1, -1, 0], [-1, 1, 0],
   [1, 1, 0], [1, -1, 0]
face.pushpull 1
# 创建并填充数组
vertex_array = []
ents.each {|ent|
   if ent.typename == "Edge" &&
      vertex_array = vertex_array | ent.vertices
   end
}
vertex_array.each {|pt| puts "Point: " + pt.position.to_s}
```
在这种情况下，数组仅包含唯一的Vertex对象。这是因为union运算符|，阻止vertex_array接收重复元素。

### 平滑对象中的边线
 在SketchUp中，您可以通过选择对象，右键单击并选择“柔化/平滑边缘”选项来平滑对象的边缘。它在代码中并不那么简单，但是代码案例5.5遍历模型中的每条边，确定它的点是否具有正x坐标，如果是，则将边的平滑属性设置为true。

案例 5.5: smooth_edges.rb
```ruby
# 创建图形
ents = Sketchup.active_model.entities
face = ents.add_face [-1, -1, 0], [-1, 1, 0],
   [1, 1, 0], [1, -1, 0]
face.pushpull 1
# 用正的x值平滑边缘
ents.each {|ent|
   if ent.typename == "Edge" &&
      ent.start.position.x > 0 && ent.end.position.x > 0
           ent.smooth = true;
   end
}
```
如果执行此脚本，则可以通过打开“模型信息”对话框并单击对象中的每个边缘来验证它是否正常工作。只有点具有正x值的边缘才是平滑的。


## 5.5 Ruby和SketchUp中的文件
随着您的SketchUp经验的增长，您会发现自己处理许多不同类型的文件，例如模型文件（* .skp），材质文件（* .skm），样式文件（* .style）和组件定义文件（* .skp）。您可能还需要经常从其他工具导入和导出文件。因此，了解如何查找，读取和修改文件是非常重要的。 

Ruby文件操作提供了两个主要的类：Dir和File。第一个类表示当前工作目录和目录内容。第二提供了创建，读取和修改新文件的方法。本节将探讨这两者，并展示Sketchup模块中的方法如何使访问顶级SketchUp目录中的文件变得容易。
### 创建和打开文件
File类中的new和open方法以相同的方式调用并执行相同的任务：它们创建并打开新的文件或打开现有的文件，并返回File对象。两种方法都需要两个String参数：文件的名称和标识文件应以何种模式打开的符号。表5.2列出了可用的模式。

表5.2 
文件打开模式 

| 符号      | 模式    |  描述  |
| --------- | -------- | ----- |
| r | 只读 | 打开一个现有文件，以便从文件的开头读取数据(默认模式)。|
| r+ | 读写 | 打开现有文件，以便在文件开头读取或写入数据。 | 
| w | 只写 | 清除现有文件或创建新的内容。打开文件以在文件开头写入数据。 |
| w+ | 读写 | 清除现有文件或创建新的内容。打开文件以在文件开头读取或写入数据。 |
| a | 只写 | 创建新的文件或打开现有的文件。在文件末尾写入数据。 |
| a+ | 读写 | 创建新的文件或打开现有的文件。在文件末尾读取或写入数据。 |

注意w / w +模式和a / a +模式之间的区别。w / w +模式开始在文件的开头写入，并删除文件的内容（如果存在）。a / a +模式在文件末尾写入数据，不删除文件的内容。 

例如，以下命令创建一个名为new_file.txt的文件，以读写模式打开它，并返回一个File对象： 

```ruby
new_file = File.new "new_file.txt", "w+"
```
可以使用open方法执行相同的操作，如下所示： 
```ruby
new_file = File.open "new_file.txt", "w+"
```
File.open和File.new的默认用法以只读模式打开现有的文件。例如，以下每条命令都会以old_file.txt打开并进行读取。 
```ruby
file = File.new "old_file.txt", "r"
file = File.open "old_file.txt", "r"
file = File.new "old_file.txt"
file = File.open "old_file.txt"
```
如果使用模式r或r +调用new或open，则该文件必须已存在于当前目录中。如果您尝试使用这些模式之一创建文件，您将收到ENOINT错误，因为该文件不存在。 

创建文件后，可以使用chmod方法设置其权限。它接受遵循UNIX文件权限建立的约定的数值。也就是说，该值由三个八进制值来组成：所有者的权限，用户组的权限以及其他人的权限。 
*   每个八进制值的第一位标识是否可以读取文件
*   每个八进制值的第二位标识是否可以写入文件
*   每个八进制值的第三位标识是否可以执行该文件

例如，假设您要创建一个名为ex_file的文件，并且您希望所有者（您）具有读取，写入和执行权限（111 = 7）。您希望组的成员具有读取和执行权限（101 = 5），而其他成员只具有读取权限（100 = 4）。在这种情况下，您将执行以下命令： 
```ruby
new_file = File.new "ex_file", "w+"
new_file.chmod 754
```
chmod的实际操作取决于您的操作系统的策略。 
### 从文件中读取数据
在读取或读写模式下打开文件后，有许多方法可用于访问其数据。它们根据要读取的数据的性质 - 字节或文本行而不同 - 以及操作是应该执行一次还是重复执行。大多数可用方法列出如下： 
*   getc / readchar - 从文件中读取一个字节
*   read - 从文件中读取多个字节并将它们存储在可选的缓冲区中
*   each_byte - 遍历文件中的字节件
*   gets / readline - 从文件中读取一行文本
*   each / each_line - 遍历文件中的行
*   readlines - 根据文件中的行形成一个数组

getc方法和readchar方法都返回正在读取的字节的数值。chr方法将此数字转换为其对应的字符。例如，如果文件中的第一个单词是That，则getc和readchar方法会产生以下结果：
```ruby
file.getc
      → 84        # 对应于“T”
file.getc.chr
      → h
file.readchar
      → 97        # 对应于“a”
file.readchar.chr
      → t 
```
这些读取操作从文件的开头开始，一次进行一个字符。 rewind方法重置指针，以便下一个读或写操作将从文件的头部开始。 

以下代码将指针重置为仅包含单词That的打开文件的开头。它调用read将四个字节存储在缓冲区中，然后使用each_byte方法将字节值加在一起： 
```ruby
file.rewind
buff = file.read
      → That
file.rewind
sum = 0
file.each_byte {|b| sum = sum + b}
sum
      → 401
```
如果没有参数，read方法将读取文件中的每个字节并以String形式返回它们。它可以采用两个可选参数，第一个定义应该读取多少字节。第二个标识现有的String对象以保存读取的字节。例如，以下命令从文件中读取三个字节并将它们放在名为buffer的String中： 
```ruby
buffer = ""
file.read 3, buffer
```
gets和readline方法都返回一个String，其中包含指针到当前行末尾的字符。类似地，each和each_line方法遍历文件中的行。readlines方法从文件中的行形成一个数组，使用方法如下： 
```ruby
arr = file.readlines
      → ["One\n", "Two\n", "Three\n", "Four\n"]
```
这允许您使用行号访问文件数据。readlines方法的另一个优点是，您可以指定除换行符之外的String，以将其识别为行分隔符。例如，以下命令从File对象中的逗号分隔值创建数组： 
```ruby
arr = file.readlines ","
      → ["One,", "Two,", "Three,", "Four\n"]
```
这对于读取从电子表格或数据库创建的文件非常有用。 
### 将数据写入文件
在File类中，可用于写入数据的方法类似于读取数据的方法，但是在写入字符或文本行之间没有区别。主要方法如下： 
*   putc - 将一个字节/字符写入文件
*   print / write - 将字符串写入文件（无换行符）
*   puts - 将一个字符串写入文件（添加换行符）
*   printf - 将格式化字符串写入文件

putc方法接受对应于字节（0到255之间）或字符的数字。例如，以下命令都将字符A写入文件对象表示的文件： 
```ruby
file.putc 65       # 65是字符A的ASCII代码
file.putc "A"
```
print，write和puts方法类似，并将字符串写入文件。print方法返回nil，write返回写入的字符数。puts方法在每个参数后面插入一个换行符，并且可以接受一个字符串数组。这由以下命令显示：
```
colors = ["Red", "Yellow", "Green", "Blue"]
file.puts colors
```
第二个命令将colors数组的每个元素写入文件中的单独行。 
列出的最后一个方法printf使用格式代码将格式化的字符串输出到文件中。这些代码几乎与printf在C编程语言中使用的代码完全相同。 
### 关闭和删除文件
close方法完成任何剩余的写操作并阻止进一步的读写操作。delete方法从文件系统中删除该文件。这在以下示例中显示： 
```
File.delete "example.txt"
```
必须先关闭文件才能删除它。如果您尝试删除打开的文件，则会收到一条错误消息，指出该权限已被拒绝。 

案例5.6中的代码显示了如何使用close和delete方法。脚本写入文件，从文件读取，关闭文件并删除文件。 

案例 5.6: file_ops.rb
```ruby
# 以读写模式创建/打开文件
f = File.open "example.txt", "w+"
# 将一个由五个字符串组成的数组写入文件
nums = ["One", "Two", "Three", "Four", "Five"]
f.puts nums
# 返回文件，读取其行，并输出第三行f.rewind
arr = f.readlines
puts arr[2]
# 关闭文件
f.close
puts "Closed? " + f.closed?.to_s
# 删除文件
File.delete "example.txt"
puts "Exists? " + File.exists?("example.txt").to_s
```
请注意close和delete方法之间的使用差异。close方法在File对象上运行，并使用f.close调用。但是像File.new和File.open一样，delete是一个类方法，这意味着它必须被称为File.delete。 
### 目录操作 
在前面的每个示例中，已从工作目录中创建或打开文件。这是所有相对路径名的基础，例如../../sample.txt。Dir类提供访问工作目录，创建新目录和列出现有目录内容的方法。 

pwd方法（输出到工作目录）显示当前工作目录的完整路径。默认情况下，这通常设置为等于HOME变量的值，在我的Windows XP系统上，这是如下： 
```ruby
Dir.pwd
      → C:/Documents and Settings/******/Desktop
```
chdir方法将工作目录更改为另一个目录。 
使用File.new和File.open创建常规文件时，使用Dir.mkdir创建目录。如果成功创建目录，则此方法返回0，而不是对象。要获取表示目录的Dir对象，您需要使用Dir.new跟随Dir.mkdir。这在以下示例中显示： 
```ruby
Dir.mkdir "folder"
      → 0
new_dir = Dir.new "folder" 
new_dir.class
      → Dir
```
如果使用不存在的目录名称调用Dir.new，则会收到错误消息，指出没有此类目录。 

close方法关闭Dir对象并阻止进一步的操作读取其文件名。Dir.rmdir方法删除文件系统中的目录，但前提是该目录为空。如果目录不为空，则rmdir会引发错误。 
### 访问目录中的文件 
一旦打开了Dir对象，就可以读取目录中的文件名，就像从文本文件中读取文本一样。也就是说，您可以调用read方法来读取目录中的连续文件名。此外，Dir类中的entries方法与File类的readlines方法类似，但它不是从文本行创建数组，而是根据目录中包含的文件名创建一个数组。

以下例子可以说明这一点。名为colors的文件夹包含三个文件：红色，黄色和蓝色。以下代码创建一个Dir对象，并根据其文件名称创建一个字符串数组：
```ruby
color_dir = Dir.new "colors"
arr = color_dir.entries
      → [".", "..", "blue", "red", "yellow"]
arr2 = color_dir.entries
      → []
```
对entries的第二次调用返回一个空数组，因为前一次调用读取了目录中的所有文件名。 rewind方法将指针设置为目录列表的开头。 

除了entries之外，您还可以调用每个entries来循环访问目录中的文件名。代码5.7中的代码创建了一个名为colors的目录，并插入了名为red，yellow和blue的文件。然后，使用each，它从colors目录中的文件名创建并初始化File对象数组： 

案例 5.7: dir_demo.rb
```ruby
# 创建目录及其文件
Dir.mkdir "colors"
File.new("./colors/red", "w+").close
File.new("./colors/yellow", "w+").close
File.new("./colors/blue", "w+").close

# 创建一个Dir对象并填充文件数组 color_dir = Dir.new "colors"
file_array = []
color_dir.each {|f| 
   if f[0].chr != "."
      file_array << File.new("./colors/" + f)
   end
}
# 显示文件数组中文件的名称
file_array.each {|f| puts f.path}

# 关闭和删除文件
file_array.each {|f|
   filename = f.path
   f.close
   File.delete filename 
   puts "Deleted " + filename
}

# 关闭并删除目录
color_dir.close
Dir.rmdir "colors"
```
这段代码为每个不以点开头的文件创建一个File对象。.和..分别表示当前目录和父目录。你不能在这些特殊的目录中创建文件对象。

创建文件后，此脚本将循环访问数组中的每个File对象，并使用path方法获取其名称。然后它关闭每个File对象并调用File.delete以从文件系统中删除该文件。最后，它关闭并删除colors目录。

## 5.6 SketchUp文件访问 
除了Ruby的Dir和File类中的方法之外，您还可以使用Sketchup模块访问文件和目录。列出了四种重要方法如下： 
1. file_new - 使用新的模型设计打开SketchUp。
2. open_file - 使用现有模型文件打开SketchUp
3. find_support_file - 返回顶级文件夹中文件的路径
4. find_support_files - 返回顶级文件夹中多个文件的路径

前两种方法改变了SketchUp的当前模型。file_new方法使用空白模型打开SketchUp。这不会为模型创建文件，因此必须使用Model.save保存模型。 

将图案保存到文件不会在SketchUp中打开文件。要打开文件，需要第二种方法open_file。清单5.8中的代码显示了这些方法如何协同工作。它打开一个空白的SketchUp设计并添加一个模型。然后它将模型保存到example.skp并在SketchUp中打开新的模型文件。 

案例 5.8: su_file.rb
```ruby
# 创建一个新的模型
Sketchup.file_new
ents = Sketchup.active_model.entities
face = ents.add_face [-1, -1, 0], [-1, 1, 0], [1, 1, 0], [1, -1, 0] face.pushpull 1

# 保存模型并在SketchUp中打开它
Sketchup.active_model.save "example.skp"
Sketchup.open_file "example.skp"
```
在安装过程中，SketchUp会创建一个名为Google SketchUp＃的目录，其中＃是SketchUp版本号。我们将此文件夹称为SketchUp的顶级文件夹。Sketchup模块中的两个文件方法find_support_file和find_support_files都返回相对于此目录的路径。

find_support_file方法接受两个参数：要查找的文件的名称以及包含该文件的顶级文件夹中的目录。例如，以下命令提供顶级SketchUp文件夹中Materials目录中Blinds / Blinds_Weave.skm文件的路径： 
```ruby
Sketchup.find_support_file "Blinds/Blinds_Weave.skm", "Materials"
      → C:/Program Files (x86)/Google/Google SketchUp 7/Materials/Blinds/Blinds_Weave.skm
```
在我的Mac OS X系统上，其路径如下： 
```ruby
Sketchup.find_support_file "Blinds/Blinds_Weave.skm", "Materials"
      → /Library/Application Support/Google SketchUp 7/SketchUp/Materials/Blinds/Blinds_Weave.skm
```
如果找不到该文件，则该方法返回nil。 

常见的SketchUp任务是找到SketchUp的Plugins文件夹的路径。这是通过以下命令完成的： 
```ruby
Sketchup.find_support_file "Plugins", ""
```
要在顶级Plugins目录中查找Ch5目录，可以使用以下命令： 
```ruby
Sketchup.find_support_file "Ch5", "Plugins"
```
find_support_files方法与find_support_file类似，但接受文件后缀并返回指定文件夹中匹配文件的路径数组。例如，以下命令返回Materials / Blinds目录中所有* .skm文件的路径数组。 
```ruby
Sketchup.find_support_files "skm", "Materials/Blinds"
```
如果后缀留空，则该方法返回给定目录中所有文件的路径。 

## 5.7 结论 
本章深入研究了我称之为Ruby的中间主题：控制结构和文件操作。这些主题将在随后的章节中发挥至关重要的作用。迭代器和块的主题特别重要，因为这些语句可以使用单行代码循环访问集合的元素。一旦你经常开始使用迭代器和块，你将永远不会回到for和while结构。 

本章的第二部分讨论了Ruby和SketchUp中的文件访问。Ruby的File类提供了执行基本文件操作的方法：创建，打开，读取，写入，关闭和删除。Dir类提供了访问目录并识别其中文件名的方法。最后，Sketchup模块提供了两对与文件相关的方法;第一对使用新文件或现有文件打开SketchUp，第二对返回SketchUp顶级目录中文件的路径。 


# 第10章 SketchUp界面：对话框，菜单，命令和插件

本章主题
* [SketchUp对话框：MessageBox和InputBox](SketchUp对话框)
* [将项目添加到主菜单和上下文菜单中](将项目添加到主菜单和上下文菜单中)
* [使用插件脚本扩充SketchUp功能](使用插件脚本扩充SketchUp功能)

SketchUp最大的优势之一是它的可扩展性：SketchUp API可以轻松添加新的功能，如照片级渲染，对象动画和与Adobe Photoshop等应用程序的文件兼容性。这些附加组件以称为插件的Ruby脚本的形式提供。 

一般来说，SketchUp插件通过向用户界面提供元素来操作，例如菜单项，工具栏，对话框或页面。如果您打算为SketchUp创建重要的插件，您需要知道如何连接这些区域。本章首先讨论对话框和菜单项，然后展示它们如何在完整的SketchUp插件脚本中协同工作。下一章继续讨论插件和SketchUp UI，并展示如何添加新工具，工具栏和页面。

## 10.1 对话框和UI模块
UI模块包含许多方法，这些方法与SketchUp用户界面的不同方面进行交互。它们分为四大类： 
1. Dialogs(对话框) - 创建简单的对话框并打开现有对话框
2. Timers and Sounds(计时器和音频) - 监测时间并播放音频文件
3. Menus(菜单)  - 创建菜单条目并在选择条目时作出响应
4. Tools (工具) - 访问SketchUp工具栏及其内容

本节详细讨论前两个主题，第10.2节讨论菜单。下一章深入研究第四类，它涉及SketchUp工具栏。
### Dialogs(对话框) 
对话框使得使用用户和应用程序之间交换信息变得容易。通过调用UI模块中的方法，您可以创建三种类型的对话框：
*   提供消息和接收输入的简单对话框
*   用于打开和保存SketchUp文件的对话框
*   现有SketchUp配置对话框：模型信息和系统首选项

图10.1显示了两个最简单的SketchUp对话框：消息框和输入框。 
![1](/img/Ruby/Chapter_10/1.png)
<center>图10.1：MessageBox和InputBox  </center>

第一个对话框，我们将其称为消息框，向用户显示警告或通知。这可以配置各种不同的按钮排列，从单个OK按钮到三个按钮：读取中止，重试和取消。UI.messagebox方法创建一个这种类型的对话框，它接受一到三个参数： 
*   message - 在框中显示为消息的字符串
*   type - 一个常量，用于定义要添加到框中的按钮（可选）
*   title - 标题栏中显示的字符串（可选）

例如，用于创建图10.1中的消息框的命令：
```ruby
UI.messagebox "This is a message box!", MB_OKCANCEL
```
第二个参数type定义了对话框中应出现的按钮。只要按下任何按钮，消息框就会关闭，消息框方法会根据按下的按钮返回一个值。以下列表显示了类型的每个可能值以及与每个类型相关联的按钮。按下按钮返回的值括在括号中：
*   MB_OK - 仅包含一个OK按钮（1）
*   MB_OKCANCEL - 包含OK按钮（1）和取消按钮（2）
*   MB_RETRYCANCEL - 包含重试按钮（4）和取消按钮（2）
*   MB_ABORTRETRYCANCEL - 包含中止按钮（3），重试按钮（4）和取消按钮（2）
*   MB_YESNO - 包含是按钮（6）和否按钮（7）
*   MB_YESNOCANCEL - 包含“是”按钮（6），“否”按钮（7）和“取消”按钮（2）
*   MB_MULTILINE - 仅包含一个OK按钮，返回1

在撰写本文时，只有将type设置为MB_MULTILINE时，第三个参数title才能正常工作。对于任何其他类型的对话框，无论方法中定义了什么标题，标题都将设置为SketchUp。

除了消息框之外，UI模块还提供输入框，该输入框创建一个对话框，其文本框以字符串的形式从用户接收信息。与messagebox一样，inputbox接受三个参数，后两个是可选的：
1. 	labels - 一个字符串数组，用于标识要输入的输入
2. 	defaults - 三个输入的默认值数组（可选）
3. 	title - 对话框标题栏中显示的字符串（可选）

第二种类型的自定义对话框是使用UI.inputbox方法创建的输入框。这将创建接收用户输入的文本框。因此，UI.inputbox返回一个字符串数组而不是数字。案例10.1显示了如何在代码中创建输入框。它调用UI.inputbox来创建一个返回两个字符串的输入框。然后，使用UI.messagebox，它创建一个消息框，其标题和消息设置为等于两个字符串。 

案例 10.1: dialogs.rb
```ruby
# 创建输入框
prompts = ["Title", "Message"]
defaults = ["Dialog Title", "World peace"]
results = inputbox prompts, defaults, "Inputbox Example"

# 创建消息框 
UI.messagebox results[1], MB_MULTILINE, results[0]
```
在图10.2中，左侧对话框是一个带有两个文本框和两个按钮的输入框。如果按下确定按钮，则在文本框中输入的值将用于初始化右侧显示的消息框。消息框的类型为MB_MULTILINE，仅提供“确定” 按钮。 
![2](/img/Ruby/Chapter_10/2.png)
<center>图10.2：示例对话框  </center>

除了创建输入框和消息框之外，您还可以打开文件访问和SketchUp配置的对话框。与文件对话框相关的方法是UI.openpanel和UI.savepanel。第一个创建SketchUp Open对话框，第二个创建Save对话框，两个都接受相同的三个参数：
1. 	title - 对话框标题栏中显示的字符串
2. 	dir - 对话框中打开的初始目录
3. 	file - 要打开或保存的初始文件的名称

例如，以下命令创建一个名为Custom Save的Save对话框，将当前模型命名为new_file.skp并保存到C:/designs当中：
```ruby
path = UI.savepanel "Custom Save", "C:/designs", "new_file.skp"
```
UI.openpanel和UI.savepanel创建的对话框实际上不会打开或保存SketchUp文件。如果存在正在打开的文件，UI.openpanel将返回文件的路径，如果该文件不存在或用户单击“取消”，则该方法返回nil。同样，如果用户单击“保存”，UI.savepanel将返回文件的路径，如果用户单击“取消”，则返回nil。实际的文件操作必须在代码中单独执行，第5章讨论如何在Ruby中打开和保存文件。 

UI模块中最后一组与对话框相关的方法处理配置设置，特别是在SketchUp的“模型信息”对话框（“窗口”>“模型信息”）和“系统首选项”对话框（“窗口”>“首选项”）中。这四种方法如下： 
1. 	UI.model_info_pages - 列出“模型信息”对话框中的页面条目
2. 	UI.show_model_info - 打开SketchUp特定页面的“模型信息”对话框
3. 	UI.preferences_pages - 在“系统首选项”对话框中列出页面条目
4. 	UI.show_preferences_pages - 打开SketchUp的“系统首选项”

对话框以下命令显示如何使用第一种方法： 

```ruby
UI.model_info_pages
       → ["分类", "动画", "单位", "地理位置", "尺寸", "文件", "文本", "渲染", "版权信息", "组件", "统计信息"]
```
获得页面名称后，可以通过使用页面名称调用UI.show_model_info来打开特定页面。例如，以下命令显示与模型渲染相关的信息。 
```ruby
UI.show_model_info "Rendering"
```
使用首选项页面类似：调用UI.preferences_pages以访问页面的名称，然后使用名称调用UI.show_preferences_pages以显示“系统首选项”对话框中的相应条目。 
###  计时器和音频
UI模块提供了四种与操作系统交互的方法，以执行无法使用常规Ruby命令执行的操作。这些为： 
*   UI.beep - 播放系统蜂鸣声
*   UI.play_sound - 播放音频文件
*   UI.start_timer - 在给定的秒数内启动计时器
*   UI.stop_timer - 停止正在运行的计时器

前两种方法很简单。第二个UI.play_sound接受音频文件的名称作为其参数。可以在SketchUp中播放的声音文件类型取决于您的操作系统。 

与C和Java不同，Ruby不提供定义给定任务应执行多长时间的方法。但SketchUp提供了使用UI.start_timer和UI.stop_timer方法访问计时器的权限。这两种方法在第12章中扮演了重要角色，第12章讨论了SketchUp动画。

UI.start_timer方法接受两个参数和一个用大括号括起来的过程块。UI.start_timer的第一个参数标识等待的秒数，第二个参数可选地标识处理块是否应重复。默认情况下，块不重复。 

例如，以下命令告诉SketchUp在发出系统蜂鸣声之前等待5秒： 
```ruby
UI.start_timer(5) { UI.beep }
```
此命令告诉SketchUp每4秒重复发出一声蜂鸣声： 
```ruby
UI.start_timer(4, true) { UI.beep }
```
注意：start_timer方法中的括号和花括号是必需的，而不是可选择不添加的。 

UI.start_timer返回唯一标识计时器的数字。UI.stop_timer方法接受此标识符，如果尚未停止，则暂停计时器。例如，您可以使用以下命令告诉SketchUp重复发出蜂鸣声：
```ruby
timer_id = UI.start_timer(4, true) { UI.beep }
```
然后您可以用这个命令停止哔哔声： 
```ruby
UI.stop_timer timer_id
```

## 10.2 菜单
SketchUp菜单采用两种形式之一。最突出的一组菜单选项列表在应用程序标题栏下面的主菜单中。如果右键单击绘图窗口中的对象，则会在称为上下文菜单的第二个菜单中显示选项列表。本节介绍如何向两种菜单添加条目。

在这两种情况下，通过调用UI模块中的方法，然后配置Menu对象来创建菜单条目。此Menu对象定义相应菜单项的行为。 
### 修改主菜单 
在SketchUp窗口的顶部，您将看到名为“文件”，“编辑”，“查看”等标题。这些菜单中的每一个都由Menu对象在代码中表示。方便的是，UI模块中的菜单方法接受String参数并返回相应的Menu。

例如，以下命令返回与“视图”菜单对应的Menu对象： 
```ruby
view_menu = UI.menu "View"
view_menu.class
       → Sketchup::Menu
```
一旦有了Menu对象，就可以调用它的四种方法，如下所示： 
1. 	add_item - 创建一个新的菜单项，并定义在选择时应执行的过程
2. 	add_submenu - 返回一个Menu对象，作为当前Menu对象的子菜单
3. 	add_separator - 添加一行以将菜单项与以下项和子菜单分开
4. 	set_validation_proc - 检查当前设计的状态以确定应如何呈现菜单条目

在我们详细研究这些方法之前，让我们看一个简单的例子。清单10.2显示了如何一起使用所有四个Menu方法。 

案例 10.2: view_menu.rb
```ruby
# 程序的第一个菜单项
def item1
   UI.messagebox "好极了! 是六月份!"
end

# 程序的第二个菜单项
def item2
   UI.messagebox "不是六月份。"
end

# 第一个菜单项的验证过程
def validate1
   (Time.new.month == 6) ? MF_ENABLED : MF_GRAYED
end

# 第二个菜单项的验证过程 
def validate2
   (Time.new.month == 6) ? MF_GRAYED : MF_ENABLED
end

# 访问主视图菜单
view_menu = UI.menu "View"

# 添加分隔符和子菜单
view_menu.add_separator
sub_menu = view_menu.add_submenu("June Check")

# 将两个菜单项添加到子菜单
it1 = sub_menu.add_item("Item 1") {item1} 
it2 = sub_menu.add_item("Item 2") {item2}

# 验证两个菜单项
sub_menu.set_validation_proc(it1) {validate1} 
sub_menu.set_validation_proc(it2) {validate2}
```
此列表中的代码在SketchUp的View菜单末尾添加了一个子菜单，名为June Check。选择此子菜单时，将显示另外两个菜单项：Item1和Item2。两者都有与之关联的验证程序，并且只有当前月份为6月时才会启用第一项。如果当前月份不是6月，则启用第二项。 

图10.3显示了子菜单和菜单项的外观。如图所示，此脚本在6月份没有被执行。 
![3](/img/Ruby/Chapter_10/3.png)
<center>图10.3：菜单和子菜单项 </center>

重要的是不要混淆add_submenu和add_item。两种方法都创建命名菜单项，但add_submenu返回一个Menu对象，可以向其添加更多项。add_item方法创建一个菜单项，在选择时执行过程。此项由方法返回的数字句柄唯一标识。 

set_validation_proc方法确定菜单项的显示方式以及用户是否可以访问它们。它接受类似于add_item的过程块，但块必须返回以下五个值之一： 

1. 	MF_ENABLED（默认值） - 如果选择了项目，将执行项目的过程
2. 	MF_DISABLED - 如果选择了该项，则不会执行该项的过程
3. 	MF_CHECKED - 项目旁边显示一个复选框
4. 	MF_UNCHECKED - 项目未选中（类似于MF_ENABLED）
5. 	MF_GRAYED - 项目呈灰色且无法访问

注意：在撰写本文时，MF_DISABLED标志不会禁用菜单项。 

add_item中定义的代码块仅在启用并选择项目时执行。set_validation_proc方法中的代码块被重复执行。因此，最好在set_validation_proc过程中尽可能少地处理。
### 添加到上下文菜单
在SketchUp中，右键单击绘图窗口中的对象时会出现上下文菜单。向此菜单添加条目类似于向主菜单添加条目 - 唯一的区别是如何获取Menu对象。在前面的讨论中，我们通过调用UI.Menu获得了Menu对象。但是对于上下文菜单，我们在UI模块中使用另一种方法：UI.add_context_menu_handler。

UI.add_context_menu_handler方法接受过程块并提供表示Menu对象的占位符。例如，以下代码访问上下文菜单并添加一个名为Hi的项。
```ruby
UI.add_context_menu_handler {|m| m.add_item("Hi") {} }
```
在此示例中，m是Menu对象，您可以调用add_item，add_submenu和set_validation_proc等方法。set_validation_proc对于上下文菜单变得特别重要，因为菜单的条目通常对所选对象进行操作。案例10.3显示了这一点，它添加了一个名为Make Blue的上下文菜单条目。仅当用户在设计窗口中的选择包括Face时，才会启用此条目。

案例 10.3: context_menu.rb
```ruby
# 将所有绘制元素涂成蓝色的过程 
def make_blue
   sel = Sketchup.active_model.selection    
   sel.each do |e| 
      e.material = [200, 200, 255]
      if e.typename == "Face"
      e.back_material = [200, 200, 255]
      end
   end
end

# 以确保是一个面
def check_face
   sel = Sketchup.active_model.selection    
   ok = sel.find{ |e| e.typename == "Face"}    
   ok ? MF_ENABLED : MF_GRAYED
end

# 访问SketchUp的上下文菜单 
UI.add_context_menu_handler do |menu|

   # 向上下文菜单添加项
   menu.add_separator
   item = menu.add_item("Make Blue") { make_blue }

   # 检查以确保面被选上 
   menu.set_validation_proc(item) { check_face }
end
```
要测试此脚本，请使用矩形工具在绘图窗口中创建曲面。左键单击选择曲面，然后右键单击激活上下文菜单。在此菜单中，选择名为Make Blue的条目。这将使背面着色。

如果当前选择不包含Face，则set_validation_proc例程返回MF_GRAYED，并且菜单项显示为灰色。如果启用并选择了菜单项，则其过程将遍历每个选定的实体并将其材质设置为蓝色（200,200,255）。



## 10.3 命令 
前一章解释了SketchUp API如何使用*Observer类(比如SelectionObserver和EntitiesObserver)实现Observer模式。SketchUp API还通过提供命令类来实现命令模式。在SketchUp中，Command标识可以通过菜单项或工具选择执行的过程。创建命令后，可以将其与菜单项，工具栏项或两者相关联。

一个例子将有助于明确这一点。案例10.4中的代码实现了与案例10.3中相同的结果，但它没有单独定义菜单的执行过程和验证过程，而是创建了一个Command。

案例 10.4: blue_command.rb
```ruby
# 创建命令对象 
cmd = UI::Command.new("Make Blue") {
   sel = Sketchup.active_model.selection    
   sel.each do |e| 
      e.material = [200, 200, 255]
      if e.typename == "Face"
      e.back_material = [200, 200, 255]
      end
   end
}

# 验证程序-检查Face
cmd.set_validation_proc {
   sel = Sketchup.active_model.selection 
   ok = sel.find{ |e| e.typename == "Face"} 
   ok ? MF_ENABLED : MF_GRAYED
}

# 访问SketchUp的上下文菜单
UI.add_context_menu_handler do |menu|
   menu.add_separator    
   menu.add_item cmd
end
```
尽管它们完成了相同的结果，但代码案例10.4中的代码比10.3中的代码简单得多。这有两个原因。首先，不是创建两个方法，而是列表中的代码 10.4 调用Command类的两个方法： 
*   new - 接受Command的显示字符串以及执行Command时应调用的过程 - 它返回Command对象
*   set_validation_proc - 确定应如何显示Command

其次，代码不需要调用Menu类的多个方法。它只是使用Command对象调用add_item，而不是识别执行和验证过程。Command对象处理所有内容，包括设置菜单项的名称。 

如附录A中所示，Command类提供了一种在菜单中设置其外观的方法（menu_text =）和三种在工具栏中设置属性的方法（small_icon =，large_icon =和tooltip =）。我们将在下一章讨论这些方法，讨论工具和工具栏。 

## 10.4 插件 
如果您想扩展SketchUp的功能，您可以找到许多提供插件的网站。有些是免费的，有些则不是，但安装过程通常是相同的：将Ruby脚本或脚本放在SketchUp的Plugins文件夹中并启动SketchUp。如果关注其他国家的用户使用，您可能必须将资源文件放在相应的Resources子目录中。 

这个程序与我们使用的程序明显不同。到目前为止，我们所有的示例脚本都必须使用load命令手动加载。但是当一个脚本是 
置于插件目录内，当SketchUp启动时会自动加载。因此，目录放置是插件和常规脚本之间唯一的差异就是其加载方式上的区别。 

然而，SketchUp插件的期望远远超过常规脚本。简而言之，插件应该是专业和安全的。不过需要遵循以下条例： 
*   插件代码应符合Ruby编码的最高标准
*   插件不应干扰SketchUp或其他插件的操作
*   应该在模块中定义插件的方法以防止命名空间冲突
*   在插件开始执行之前，应检查以确保它尚未加载
*   应该在插件中使用很少的全局变量，理想情况下没有
*   插件应将用户可读的文本存储在单独的资源文件中
*   理想情况下，插件应该在SketchUp支持的每个操作系统中都能正常运行。

这些规则可能看起来很严苛，但是当您分发插件时，您的用户/客户将会非常感谢您编写专业代码所花费的时间。为了给予插件开发，SketchUp附带了两个有用的插件： 
1. sketchup.rb - 包含用于访问菜单和其他插件的帮助程序
2. langhandler.rb - 包含用于访问资源文件中的文本的程序

在撰写本文时，这两个脚本都位于SketchUp的Tools文件夹中 (SketchUp.app>Contents>Resources>Content>Tools下)，可以将其视为Google的特定插件目录。常规插件通常放在Plugins文件夹中。


### sketchup.rb
sketchup.rb脚本包含五种实用程序方法，可以更轻松地编写插件。 他们是由
1. 	inputbox - 创建一个输入框对话框，就像UI.inputbox方法创建的那样
2. 	add_separator_to_menu - 在命名菜单的末尾添加分隔线
3. 	require_all - 从不同的目录加载文件，就像它们是插件一样
4. 	file_loaded - 将文件名添加到插件的数组中
5. 	file_loaded？- 返回文件名是否是插件数组的元素

前三种方法很容易理解，但最后两种方法需要解释。初始化时，sketchup.rb脚本会创建一个名为loaded_files的空数组。如果插件使用其名称调用file_loaded，则String将添加到数组中。然后，插件可以通过调用file_loaded来检查其名称是否在数组中？方法。 

这个检查很重要，在许多插件中，它是第一个被调用的方法。通过此检查，您可以确保您的插件只会加载一次。这显示在以下插件框架中： 
```ruby
require "sketchup.rb"
..
if( not file_loaded? "example_plugin.rb" )
   ..执行处理..
   file_loaded "example_plugin.rb"
end
```
当SketchUp在启动期间加载example_plugin.rb时，插件调用file_loaded？ 查看其名称是否已添加到sketchup.rb创建的数组中。如果没有，则插件执行它的处理然后调用file_loaded。这会将插件的名称添加到数组中，并确保不会再次执行插件的处理。
### langhandler.rb
langhandler.rb脚本提供的方法可以访问资源文件中包含的字符串。资源文件由name = value组成;pair，其中value是要在SketchUp用户界面中显示的字符串，name是用于访问代码中字符串的KEY值。例如，SketchUp资源文件中可以包含以下行： 
```ruby
"menu_name"="Triangulation";
"menu_item1"="Ear clipping method";
"menu_item2"="Seidel method";
```
这似乎是不必要的 - 为什么当你可以直接使用“Seidel方法”时访问资源文件中的“menu_item2”？总之，国际化。当您希望将插件分发给使用不同语言的用户时，资源文件至关重要。 

例如，如果插件用户说西班牙语，那么将menu_name设置为“Triangulación”而不是“Triangulation”会更好。您可以完全重写西班牙语版本的插件，但创建包含匹配对的单独资源文件会更容易： 
```ruby
"menu_name"="Triangulación"
```
资源文件放在SketchUp的Resources文件夹中，该文件夹位于适合该语言环境的子目录中。例如，America的资源文件放在Resources / en-US文件夹中，France的文件放在Resources / fr-FR中，意大利的文件放在Resources / it-IT文件夹中。 

如果您分发包含资源文件的插件，则应确保它们位于正确的文件夹中。一个好方法是将插件作为zip文件发布，并让用户在顶级SketchUp目录中获取存档文件。 

要理解我所讲的，请查看Ch10文件夹中的menu_plugin.zip文件。如果在顶级SketchUp目录中解压缩，则脚本和资源文件将放置在适当的位置。或者，插件代码可以根据需要移动资源文件。 

langhandler.rb脚本定义了一个名为LanguageHandler的类，其方法提供对资源文件的访问。使用资源文件的名称创建LanguageHandler对象时，可以通过调用GetString来访问文件的字符串。例如，假设您的资源文件的名称是example.strings，它包含匹配的对：
```ruby
"greeting"="Hello world"
```
您可以使用以下代码从插件访问String： 
```ruby
require "langhandler.rb"
..
handler = LanguageHandler.new "example.strings"
name = handler.GetString "greeting"
```
最后一个命令将name设置为Hello world。在我的系统上，example.strings文件将放在Resources / en-US目录中，但代码不识别语言环境。相反，GetString自动访问正确的文件夹。 

案例10.5给出了一个插件，它将我们在本章中介绍的所有内容联系在一起。 首先，它创建一个Command并将其与两个菜单项相关联：一个在SketchUp的Edit菜单中，另一个在上下文菜单中。该插件还从名为basic.strings的资源文件中访问String（假设您的语言环境是en-US）。选择任一菜单项时，它会在对话框中输出访问的String。 

案例 10.5: menu_plugin.rb
```ruby
require "sketchup.rb"
require "langhandler.rb"

# 检查插件是否已经加载
if not file_loaded? "menu_plugin.rb" 
   cmd = UI::Command.new("Say Hello!") {
   
      # 使用给定名称访问字符串       
      handler = LanguageHandler.new "basic.strings"       
      display_text = handler.GetString "greeting"
      
      # 创建对话框
      UI.beep
      UI.messagebox display_text
   }
   
   # 访问SketchUp的编辑菜单
   edit_menu = UI.menu "Edit"
   edit_menu.add_separator
   item = edit_menu.add_item cmd
   
   # 访问SketchUp的上下文菜单    
   UI.add_context_menu_handler do |menu|
      menu.add_separator       
      item = menu.add_item cmd
   end
   
   # 将插件标记为已加载    
   file_loaded "menu_plugin.rb"
end
```
案例10.5中的代码可以像常规脚本一样加载，但这不是插件应该执行的方式。首先，解释器将无法找到basic.strings资源文件。 
相反，将menu_plugin.zip文档放在SketchUp的顶级目录中并解压缩。这将把menu_plugin.rb放在Plugins目录中，将basic.strings放在 资源/ en-US目录。当您重新启动SketchUp并选择主菜单条目或上下文菜单条目时，您将看到显示相应字符串的对话框。 

## 10.5 结论 
本章中的概念很简单，但模块和类可能会令人困惑。有一个用于菜单项（菜单）的类，但没有用于对话框的类。然而，要创建任何一个，您必须访问UI模块的方法，这也提供了涉及蜂鸣声和计时器的奇怪方法。

好像这还不够，您可以通过将项目与Command相关联来分离菜单项的执行。Command对于菜单条目不是必需的，但是对于工具的操作是至关重要的。命令和工具将在下一章中进一步讨论。

本章的最后一部分讨论了插件。从实际角度来看，插件和常规Ruby脚本之间的唯一区别是插件必须位于SketchUp顶级目录的Plugins文件夹中。从这里开始，SketchUp启动时会自动加载。 

但是，从编码的角度来看，创建插件时应该记住一些经验法则。如果您遵循这些指导原则，您的插件不仅可以正常运行，而且还可以在诸如此类的网站上进行分发[http://www.smustard.com](http://www.smustard.com)不用担心会让用户失望。 


# 第11章 SketchUp界面：视图、相机、页面和工具

本章主题
* [设置视图和相机的角度](设置视图和相机的角度)
* [创建具有多个页面的设计](创建具有多个页面的设计)
* [将新的工具栏和工具添加到SketchUp UI上](将新的工具栏和工具添加到SketchUp用户界面上)

## 11.4 工具栏
SketchUp最友好的一个方面是它的工具栏，它的外观和行为与Adobe Photoshop和Microsoft Paint等应用程序中的工具栏类似。工具栏上的每个类似按钮的条目称为工具，并且任何时候只能激活一个。激活时，工具会告诉SketchUp如何解释绘制窗口中的事件。 

例如，当“矩形”工具处于活动状态时，鼠标单击将被解释为设置矩形面的相对顶点。当“线条” 工具处于活动状态时，鼠标单击将被解释为设置线段的端点。

SketchUp默认只提供一个工具栏，但可以一次显示多个工具栏。为此，请打开SketchUp并转到 “视图”>“工具栏”。子菜单将显示一个工具栏列表，您可以同时打开其中一个，部分或全部。 

在代码中，您可以通过调用UI :: toolbar_names来获取可用工具栏的列表。您可以使用UI :: toolbar_visible？查看给定的工具栏是否可见。例如，以下代码列出了SketchUp中当前可见的所有工具栏： 
```ruby
UI::toolbar_names.each do |name|
   puts name if UI::toolbar_visible? name
end
```
注意：如果选择了“入门”工具栏，此代码将打印GettingStarted，但如果选择“大工具集”，则不会输出任何内容。 

每个工具栏都有一个相应的工具栏对象，UI.toolbar方法返回与工具栏名称匹配的工具栏。例如，要访问名为GettingStarted的工具栏，请输入以下行： 
```ruby
gs_bar = UI::toolbar "GettingStarted"
```
Toolbar类中与我们有关的主要方法是add_item，它接受一个Command。前一章解释了命令如何与菜单项交互，它们以相同的方式与工具栏交互。首先，Command调用其验证过程（set_validation_proc）以确定是应该启用还是灰显。如果它已启用且用户选择它，则执行Command的构造函数中定义的代码块。 

在继续之前，让我们看一个简单的例子。案例11.3中的代码创建了一个名为basic_toolbar的新工具栏，并添加了一个名为basic_cmd的项。执行时，此命令显示带有问候语的对话框。
```ruby
# 创建Command对象
basic_cmd = UI::Command.new("Basic") {
   UI.messagebox "Hello from the basic command!"
}

# Command的验证过程 —— 在本例中不适用
basic_cmd.set_validation_proc {
   true ? MF_ENABLED : MF_GRAYED
}

# 配置Command的外观
basic_cmd.small_icon = "basic_small.gif" 
basic_cmd.large_icon = "basic_large.gif"
basic_cmd.tooltip = "Basic Toolbar Entry"

# 创建和配置工具栏 
basic_toolbar = UI::Toolbar.new "Basic" 
basic_toolbar.add_item basic_cmd
basic_toolbar.show
```
执行此脚本时，SketchUp将显示一个包含单个条目的新横置工具栏。条目的图标由Command的small_icon和large_icon方法设置，通常，大图标为24×24像素，小图标为16×16。如果单击工具栏条目，Command的构造函数将执行并创建一个消息框。图11.7显示了新工具栏的外观。 
![1](/img/Ruby/Chapter_11/11.4/1.png)
<center>图11.7：带有添加条目的工具栏 </center>

大多数脚本代码都处理配置basic_cmd，但了解Toolbar类的方法很重要。其中包括： 
*   add_item - 从Command对象创建工具栏条目
*   add_separator - 在前面的工具栏条目之后插入分隔栏
*   get_last_state - 标识工具栏是可见（1），隐藏（0）还是从不显示（-1）
*   hide - 从视图中移除工具栏
*   new - 创建一个新的工具栏条目
*   restore - 重新定位工具栏并使其可见
*   show - 使工具栏可见
*   visible? - 确定工具栏当前是否可见

要将工具栏条目与工具相关联，您需要创建一个使工具成为活动工具的命令。这在以下讨论中解释

##  11.5 Tool类
在理解Tool之前，您需要了解Ruby接口。像类一样，接口定义了一组方法。但与类不同，接口中的方法没有任何代码 - 接口只是定义方法的名称及其输入和输出参数。 

类可以为接口的方法提供代码，如果它这样做，则说它实现了接口。基本原理是：如果一个类实现了一个接口，它包含一组可以以可预测的方式调用的方法。例如，如果应用程序需要调用Door界面中定义的Lock和Unlock方法，则只要两个类都实现Door，它就不关心它是否处理SlidingDoor或FoldingDoor。

Ruby没有正式的接口。相反，它有像Tool这样的类，这并不是用来扩展的。Tool类标识SketchUp在工具处于活动状态且用户执行操作时查找的方法。Tool类中的大多数方法都属于以下两种类别之一： 
1. 	Life-cycle(活动周期) - 与工具激活和操作相关的方法
2. 	Event-handling(事件处理)  - 响应用户事件而调用的方法

以下讨论解释了这两个类别中的方法。如果主题一开始看起来很复杂，请不要担心。一旦您使用示例代码并自行进行实验，这将是有意义的。 
###  SketchUp工具的活动周期
在任何给定时间，SketchUp工具栏中只能有一个工具处于活动状态。默认情况下，活动工具是“选择”工具。要在代码中激活工具，需要从Model类调用select_tool方法。例如，要使my_tool处于活动状态，您需要执行如下命令： 
```ruby
Sketchup.active_model.select_tool my_tool
```
通过将此代码放在Command构造函数中，您可以从工具栏条目激活工具。因此，您还可以从菜单中激活工具。

当新工具变为活动状态时，SketchUp会调用其激活方法。这将执行需要在Tool处理事件之前执行的初始化任务。当工具完成其操作并变为非活动状态时，deactivate方法将处理任何最终的重新分配过程。 
###  Tool的事件处理
当工具处于活动状态且用户与绘制交互时，SketchUp会调用Tool的方法进行响应。例如，如果my_tool处于活动状态且用户在窗口中双击，SketchUp将找到my_tool对象并尝试调用其onLButtonDoubleClick方法。my_tool不必具有onLButtonDoubleClick的代码，但如果有，则SketchUp将在双击事件发生时调用该方法。表11.1列出了onLButtonDoubleClick以及Tool类中的所有其他事件处理方法。 

表格11.1 
Tool类的事件处理方法 

| 方法      | 输入参数    |  描述 |
| --------- | -------- | ----- |
| onCancel | reason, view | 用户取消/撤消操作时调用 |
| onKeyDown | key, repeat, flags, view | 用户按下按键时调用 |
| onKeyUp | key, repeat, flags, view | 按键被松开时调用 |
| onLButtonDoubleClick | flags, x, y, view | 当用户双击鼠标左键时调用 |
| onLButtonDown | flags, x, y, view | 用户点击鼠标左键时调用 |
| onLButtonUp | flags, x, y, view | 松开鼠标左键时调用 |
| onMButtonDoubleClick | flags, x, y, view | 当用户双击鼠标中键时调用 |
| onMButtonDown | flags, x, y, view | 用户按下鼠标中键时调用 |
| onMButtonUp | flags, x, y, view | 松开鼠标中键时调用 |
| onMouseEnter | view | 鼠标进入绘图窗口时调用 |
| onMouseLeave | view | 鼠标离开绘图窗口时调用 |
| onMouseMove | flags, x, y, view | 用户移动鼠标时调用 |
| onRButtonDoubleClick | flags, x, y, view | 当用户双击鼠标右键时调用 |
| onRButtonDown | flags, x, y, view | 用户按下鼠标右键时调用 |
| onRButtonUp | flags, x, y, view | 松开鼠标右键时调用 |
| onReturn | view | 用户按Enter / Return时调用 |
| onUserText | text, view | 用户在值控制框（VCB）中输入文本时调用 |

请记住，这些方法由SketchUp调用，SketchUp提供输入参数。我们作为编码员的工作是为这些方法中的一个或多个添加实质内容以响应用户的行为。

案例11.6中的代码提供了响应鼠标单击的工具的简单示例。如果鼠标左键或右键单击某个点，则会在值控制框或VCB中显示该点的三维坐标。 

案例 11.6: simpletool.rb
```ruby
class SimpleTool
   # 在开始时初始化输入点    
   def activate
      @input = Sketchup::InputPoint.new
   end

   # 响应绘图窗口中的鼠标左击
   def onLButtonDown flags, x, y, view
      @input.pick view, x, y
      Sketchup::set_status_text "Left click ", SB_VCB_LABEL       
      pos = @input.position
      str = "%.2f, %.2f, %.2f" % [pos.x, pos.y, pos.z]
      Sketchup::set_status_text str, SB_VCB_VALUE
   end

   # 响应绘图窗口中的右键单击  
   def onRButtonDown flags, x, y, view 
      @input.pick view, x, y
      Sketchup::set_status_text "Right click ", SB_VCB_LABEL       
      pos = @input.position
      str = "%.2f, %.2f, %.2f" % [pos.x, pos.y, pos.z]
      Sketchup::set_status_text str, SB_VCB_VALUE    
   end
end

# 创建Command对象
simple_cmd = UI::Command.new("Simple") {
   Sketchup.active_model.select_tool SimpleTool.new
}

# 将该命令添加到Tools菜单 
tool_menu = UI.menu "Tools"
tool_menu.add_separator
tool_menu.add_item simple_cmd
```
有三点需要注意。首先，工具创建一个InputPoint以获取与鼠标单击相对应的坐标。其次，坐标显示在VCB中。最后，此工具与菜单项（“工具”）相关联，而不是工具条目。

InputPoints将二维像素坐标转换为设计中的三维坐标。要知道的两个最重要的方法是pick，它为InputPoint提供点的像素坐标，以及position，它返回点在设计中的位置。pick可以通过两种方式调用： 
1. 	pick x，y，view - 将InputPoint与View中的2-D位置相关联
2. 	pick x，y，view，input_point - 将InputPoint与View中的2-D位置相关联，使用第二个InputPoint进行推断

除了选择和定位之外，用于InputPoint方法还包括edge(边线)、face(面)和vertex(顶点)。如果InputPoint的位置位于实体上，则这些方法将返回关联的Edge，Face或Vertex。当工具需要修改现有几何体时，这可能很有用。 

VCB是SketchUp右下角的文本框。它显示SketchUp操作产生的值，还可以显示关联的标签。图11.8显示了VCB中SimpleTool输出的示例。 
![2](/img/Ruby/Chapter_11/11.4/2.png)
<center>图11.8：SimpleTool的VCB输出  </center>

Sketchup模块中的set_status_text方法配置VCB中的文本。它接受两个参数：一个String和一个定义String应该显示在哪里的常量。第二个参数可以采用以下三个值之一： 
1. 	SB_PROMPT - 文本出现在SketchUp状态行中（与Show Instructor问号相邻）
2. 	SB_VCB_LABEL - 文本显示在VCB的左侧
3. 	SB_VCB_VALUE - 文本出现在VCB中

如果您只想将输出发送到状态行，请调用Sketchup模块的 status_text= method。 

###  Tool Graphics
如果您使用SketchUp的Line或Rectangle工具并在绘图窗口中单击，您将看到该工具立即绘制图形。“线”工具从初始点到鼠标指针绘制一条线，“矩形”工具绘制一个矩形面，其对角线由初始点和鼠标指针确定。这些临时图形称为反馈，通过调用适当的方法，您可以创建反馈和您喜欢的任何其他类型的图形。 

与我们迄今为止创建的图形不同，Tool创建的图形并不对应于新的实体对象。但是，当用户完成工具操作时，可能会出现一个实体图像。例如，“线”工具在第二次单击时创建“边”，“矩形”工具在第二次单击时创建“面”。 

要绘制这些图形，您需要访问当前的视图，该视图作为表11.1中每个工具方法的最后一个输入参数提供。很多View的方法都是本章前面已经讨论过，但绘图方法完全不同。表11.2列出了View类的每种绘制方法并解释了其用途。  

表格11.2 
View类的绘制方法 

| 方法       | 描述     | 
| --------- | -------- | 
| draw_line    | 在给定一系列点的情况下绘制未连接的线 |
| draw_lines    | 在给定一系列点的情况下绘制未连接的线 |
| draw_points    | 绘制具有给定大小，样式和颜色的点 |
| draw_polyline    | 绘制给定一系列点的连接线序列 |
| draw_text    | 在绘图窗口中的指定点显示字符串  |
| drawing_color=   | 设置所有后续绘图的颜色  |
| line_width=   | 设置视图中绘制的线条的宽度  |
| line_stipple=   | 选择线是实线还是由点和破折号组成的线  |
| set_color_from_line   | 根据设计轴(x, y, z)，运用推断对线条(RGB)进行着色  |
| draw   | 根据OpenGL名称绘制形状  |
| draw2d   | 以二维方式绘制OpenGL指定的形状  |

大多数这些方法都很简单，但最后两个方法draw和draw2d涉及OpenGL® ，SketchUp用于绘制三维图像的图形库。OpenGL超出了本书的范围，因此不会讨论这些方法。 

掌握工具和视图之间关系的最佳方法是检查Tool的代码，该Tool在操作时绘制图形。案例11.4展示了一个Tool，其功能类似于SketchUp的Circle工具，但它不是创建一个圆，而是创建一个球体。SphereTool需要两个InputPoints来绘制球体：用户的第一次鼠标点击被解释为球体的中心，第二次点击被解释为球体边缘上的一个点。
```ruby
class SphereTool
   def activate
      $ents = Sketchup.active_model.entities
      
      # 被用户点击的点
      @pt1 = Sketchup::InputPoint.new
      @pt2 = Sketchup::InputPoint.new
      
      # 初始状态(用户尚未点击)      
      @first_click = false
   end

   # 如果用户单击，则绘制一条线    
   def onMouseMove flags, x, y, view
         if @first_click
            @pt2.pick view, x, y, 
            @pt1     view.invalidate
      end
   end

   # 检查状态，然后绘制一个球或一个点
   def onLButtonDown flags, x, y, view
      if @first_click  
         if (@pt1.position.distance @pt2.position) > 0
            # Remove the construction point
            $ents.erase_entities $c_point 
            draw_sphere
         end       
      else
         @pt1.pick view, x, y
         $c_point = $ents.add_cpoint @pt1.position 
         @first_click = true      
      end
   end

   def draw view
      if @first_click && @pt2.valid?
         view.set_color_from_line @pt1.position, @pt2.position 
         view.line_width = 3       
         view.draw_line @pt1.position, @pt2.position
      end
   end

   # 绘制球体    
   def draw_sphere
      # Draw the circles
      rad = @pt1.position.distance @pt2.position
      circle = $ents.add_circle @pt1.position, [1, 0, 0], rad       
      path = $ents.add_circle @pt1.position, [0, 1, 0], rad + 1       
      circle_face = $ents.add_face circle
      
      # 拉伸球体并移除拉伸路径       
      circle_face.followme path
      $ents.erase_entities path
      reset
   end

   # 恢复原状 
   def reset
      @pt1.clear
      @pt2.clear
      @first_click = false
   end

   # 当用户按下Escape时响应    
   def onCancel flags, view
      reset
   end  
end

# 创建Command对象
sphere_cmd = UI::Command.new("Sphere") {
   Sketchup.active_model.select_tool SphereTool.new
}

# 配置Command插件按钮的外观
sphere_cmd.small_icon = "sphere_small.gif" 
sphere_cmd.large_icon = "sphere_large.gif" 
sphere_cmd.tooltip = "Create a sphere"

# 创建和配置工具栏
sphere_toolbar = UI::Toolbar.new "Sphere" 
sphere_toolbar.add_item 
sphere_cmd sphere_toolbar.show
```
SphereTool包含Tool类中许多（但不是全部）方法的代码。SphereTool中的方法描述如下： 
*   activate - 此方法在SphereTool变为活动状态时执行。首先InputPoint，@ pt1，表示用户在设计窗口中的第一次单击，第二次，@ pt2代表用户的第二次点击。布尔变量@first_click标识用户是否进行了第一次单击。这被初始化为false。

*   onMouseMove - 此方法在用户移动鼠标时执行。首先检查用户是否在设计窗口中进行了第一次单击。如果是这样，它将@ pt2设置为等于鼠标的当前位置，并告诉View绘制反馈（虚线）。


*   onLButtonDown - 当用户单击鼠标左键时执行此方法。如果这是第一次鼠标单击，则此方法将@ pt1设置为等于单击点，创建一个ConstructionPoint，并将@first_click设置为true。如果这是用户的第二次鼠标单击并且第一次鼠标单击的距离大于零，则此方法将擦除ConstructionPoint并调用draw_sphere。

*   draw - 当View重绘自身时调用Tool的draw方法。这种方法定义View绘制的所有线条的外观，然后告诉View从@ pt1到@ pt2绘制一条线。 

*   draw_sphere - 这将在设计窗口中创建实际球体。它使用与第3章的sphere.rb脚本中相同的过程：它创建一个圆形面和一个圆形路径，然后调用followme来挤出球体。完成此方法后，工具的操作即完成。

*   reset - 在Tool的操作完成或取消后，此方法将Tool返回到其原始状态。具体来说，它清除@ pt1和@ pt2，并设置值@first_click为false，表示尚未收到用户的第一次点击。

*   onCancel - 当用户单击Escape或以其他方式取消Tool的操作时调用。此方法立即调用reset。

activate，onMouseMove，onLButtonDown，draw和onCancel方法在Tool类中定义。draw_sphere和reset方法特定于SphereTool。 

##  11.6 Tools类
Tools类与Entities类，Materials类或我们遇到的任何其他容器类不同。它不包含Tool对象数组，也没有用于创建新Tool对象的add方法。Model类的tools方法提供对当前Tools对象的访问，以下命令显示如何使用它： 
```
tools = Sketchup.active_model.tools
```
简单地说，Tools对象没用。它包含两个方法，active_tool_id和active_tool_name，用于标识当前活动的工具。但是，在撰写本文时，如果Tool对象不是SketchUp的一部分，则active_tool_name仅返回RubyTool。此外，当在Mac OS系统上调用active_tool_name时， SketchUp当前会截断Tool对象的名称。 

您可以将ToolsObserver与Tools对象相关联，并在用户选择其他工具时响应。但是，在撰写本文时，ToolsObserver将所有非SketchUp Tool对象称为RubyTool，并在Mac OS系统上截断工具名称。 

##  11.7 结论
本章介绍了大量内容，在本次讨论与第10章讨论之间，您应该对SketchUp插件为用户界面所做的许多贡献有一个坚实的理解。对话框，页面，菜单项和工具：如果您的应用程序需要比这些更多的图形元素，SketchUp可能不适合您。 

但在使用页面和工具之前，您需要了解SketchUp视图和相机。视图表示整个绘图窗口，其方法允许您放大图像并在像素和三维坐标之间进行转换。Camera对象代表查看器，通过更改当前Camera的属性，您可以控制查看器的位置，查看器正在查看的内容以及查看器所代表的方向。 

页面在绘图窗口中显示为选项卡，每个页面代表了查看当前图像的不同方式。每个页面将其显示属性存储在一系列对象中，您可以通过修改这些对象来配置页面。此外，当用户在Pages之间转换时，SketchUp以类似于动画的方式显示转换。我们将在下一章中更仔细地研究这一点。

本章的最后一个主题涉及工具和工具栏。创建新的SketchUp工具是一个复杂的过程，但它可以分为两个主要步骤。首先，您需要创建一个类，该类为Tool类中定义的方法提供代码。这些方法（如onMButtonUp和onMouseMove）响应用户事件。其次，你需要将命令与工具栏关联，并确保在选择相应的工具栏条目时命令激活工具。 

本章的内容并不像前几章那样简单，但我相信如果您打算构建高质量的插件，那么理解页面和工具是至关重要的。下一章将更进一步，并提出另一个不易理解的主题，但会产生令人印象深刻的结果：动画。




